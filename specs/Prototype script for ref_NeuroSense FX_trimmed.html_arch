<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptive FX Flow Meter Testbed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script> <!-- D3.js for smoothed outlines -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
            height: 100vh; /* Ensure body takes full viewport height */
            width: 100vw; /* Ensure body takes full viewport width */
            overflow: hidden; /* Prevent body scroll if content overflows */
        }

        /* New wrapper to handle overall layout and centering */
        .main-container-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%; /* Take full height of body */
            width: 100%; /* Take full width of body */
            overflow: hidden;
            flex-direction: column; /* Default for mobile: stack vertically */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .main-container-wrapper {
                flex-direction: row; /* For desktop: arrange horizontally */
            }
        }

        .control-panel {
            background-color: rgba(31, 41, 55, 0.8); /* bg-gray-800 with opacity */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.5);
            flex-shrink: 0; /* Prevent control panel from shrinking */
            width: 100%; /* Full width on mobile */
            max-height: 50vh; /* Limit height on mobile */
        }

        @media (min-width: 768px) {
            .control-panel {
                width: 320px; /* Fixed width on desktop */
                max-height: 100vh; /* Full height on desktop */
            }
        }

        .control-label {
            font-size: 0.8rem;
            font-weight: 500;
        }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 4px; background: #4b5563; border-radius: 5px; outline: none; opacity: 0.7; transition: opacity .2s; }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #60a5fa; cursor: pointer; border-radius: 50%; border: 2px solid #1f2937; }
        input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: #60a5fa; cursor: pointer; border-radius: 50%; border: 2px solid #1f2937; }
        select { background-color: #374151; border-color: #4b5563; }

        /* Toggle Switch Styles */
        .toggle-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; border-radius: 22px; }
        .toggle-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #3b82f6; }
        input:checked + .toggle-slider:before { transform: translateX(18px); }

        /* Radio Button Styles (similar to toggles for consistency) */
        .radio-group label {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .radio-group input[type="radio"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #4b5563;
            border-radius: 50%;
            margin-right: 8px;
            outline: none;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }
        .radio-group input[type="radio"]:checked {
            background-color: #60a5fa;
            border-color: #60a5fa;
        }
        .radio-group input[type="radio"]:checked::before {
            content: '';
            display: block;
            width: 8px;
            height: 8px;
            background-color: #1f2937; /* Darker center dot */
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }


        /* Visualization Area Sizing */
        .viz-wrapper {
            min-width: 100px; /* Minimum size to prevent collapse */
            min-height: 100px; /* Minimum size to prevent collapse */
            max-width: 80vw; /* Max width relative to viewport */
            max-height: 80vh; /* Max height relative to viewport */
            border: 1px solid #374151;
            padding: 0;
            margin-right: 1rem; /* Space between viz and control panel */
            position: relative; /* Needed for absolute positioning of children */
            resize: both; /* Allows user to resize both horizontally and vertically */
            overflow: auto; /* Required for 'resize' to work, handles potential overflow */
            width: 220px; /* Default starting width for the overall canvas */
            height: 120px; /* Default starting height for the overall canvas */
        }
        .visualization-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Keep internal content clipped to container */
        }

        /* New wrapper for all core visualization elements */
        #visualizationsContentWrapper {
            position: relative; /* For absolute children */
            height: 100%;
            margin: 0 auto; /* Center horizontally within vizContainer */
            /* Width will be set by JS from config.visualizationsContentWidth */
        }

        #dayRangeMeter {
            position: absolute;
            /* left: 50%; */ /* This will now be set by JS */
            top: 50%; /* Center vertically within its parent */
            transform: translateY(-50%); /* Adjust for its own width and height to truly center */
            background-color: #374151;
            border-radius: 4px;
            z-index: 1; /* Ensure meter is above market profile */
            width: 8px; /* Fixed small width for the central axis */
            border: 1px solid rgba(75, 85, 99, 0.5); /* Added for visual clarity of the meter's bounds */
        }
        /* New ADR Boundary Lines */
        .adr-boundary-line {
            position: absolute;
            width: 100%; /* Spans full visualization width */
            height: 2px;
            background-color: #6b7280; /* Gray-500 */
            z-index: 2; /* Above market profile, below priceFloat */
            transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Added transition */
        }
        /* ADR Boundary Line Pulse Effect */
        .adr-boundary-line.pulse {
            background-color: #60a5fa; /* Blue glow */
            box-shadow: 0 0 10px #60a5fa, 0 0 20px #60a5fa;
        }

        /* ADR Step Markers - now positioned absolutely by JS */
        .adr-step {
            position: absolute;
            width: 16px; /* Increased width for visibility */
            height: 2px; /* Increased height for visibility */
            background-color: #a78bfa; /* Prev color */
            border-radius: 1px; /* Rounded corners */
            transform: translateY(-50%); /* Vertically center on its own height */
            z-index: 12; /* Ensure it's in front of everything */
        }

        #priceFloat {
            position: absolute;
            height: 2px; /* Reduced height for precision as requested */
            background-color: #a78bfa; /* Changed to a softer purple for visibility */
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.9), 0 0 15px rgba(167, 139, 250, 0.6) inset; /* Adjusted shadow for thinner line for better glanceability */
            border-radius: 1px; /* Smaller rounded corners */
            transition: transform 0.1s linear, background-color 0.3s ease, box-shadow 0.3s ease; /* Modified transition */
            z-index: 10;
            /* Added for new controls: */
            /* left: 50%; */ /* This will now be set by JS */
            transform: translateY(-50%); /* Initial centering, will be adjusted by JS */
            /* TODO: In the future, the height/thickness of priceFloat could be dynamically
            determined by the bid-ask spread to visually represent market liquidity/precision. */
        }
        #priceDisplay {
            position: absolute;
            transform: translateY(-50%); /* Vertically center the text itself */
            transform-origin: center center; /* Ensure scaling is centered */
            z-index: 11; /* Ensure it's above other elements but below priceFloat */
            text-align: right; /* Align text to the right so it hugs the float */
            width: auto; /* Allow width to adjust to content */
            white-space: nowrap; /* Prevent price from wrapping */
            color: #d1d5db; /* Explicitly set to original text-gray-300 color */
            /* Custom properties for digit font sizes */
            --big-figure-font-size-ratio: 1.2;
            --pip-font-size-ratio: 1.1;
            --pipette-font-size-ratio: 0.8; /* Re-enabled as requested */

            /* NEW: Monospaced font for price display */
            font-family: 'SFMono-Regular', 'Menlo', 'Consolas', 'monospace';
            box-sizing: border-box; /* Ensure padding is included in width/height */
        }

        /* Styles for price formatting - now controlled by JS with new config values */
        #priceDisplay .big-figure {
            font-size: var(--big-figure-font-size-ratio)em;
            font-weight: 700; /* Default bold */
        }
        #priceDisplay .pip {
            font-size: var(--pip-font-size-ratio)em;
            font-weight: 600; /* Default semibold */
        }
        /* New style for the inner pipette digit */
        #priceDisplay .pipette-inner {
            font-size: var(--pipette-font-size-ratio)em;
            /* No relative positioning or top needed, as it's now inline within .pip */
        }


        #maxDeflectionMarker {
            position: absolute;
            width: 2px;
            height: 9px;
            background-color: #fca5a5;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.1s linear;
            z-index: 5;
            transform: translateY(-50%);
        }
        #volatilityOrb {
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            /* Initial background, will be overridden by JS */
            background: radial-gradient(circle, rgba(59, 130, 246, 0) 0%, rgba(59, 130, 246, 0.1) 40%, rgba(59, 130, 246, 0.2) 60%, rgba(59, 130, 246, 0) 100%);
            transition: transform 1.5s ease-in-out, opacity 1.5s ease-in-out, width 1.5s ease-in-out, height 1.5s ease-in-out, background 1.5s ease-in-out; /* Will be updated dynamically */
            transform-origin: center;
            z-index: 0; /* Moved to back */
        }
        /* Market Profile Styles */
        #marketProfileContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Behind other elements */
            overflow: hidden;
        }

        .mp-bar-buy {
            position: absolute;
            background-color: rgba(96, 165, 250, 0.5); /* Blueish for buy, matches original ticks */
            height: 1px; /* Will be set dynamically based on price bucket size */
            transform-origin: left center; /* Ensures it grows from center to right */
            transition: width 0.05s linear; /* Smooth width changes */
        }

        .mp-bar-sell {
            position: absolute;
            background-color: rgba(239, 68, 68, 0.5); /* Reddish for sell */
            height: 1px; /* Will be set dynamically based on price bucket size */
            transform-origin: right center; /* Ensures it grows from center to left */
            transition: width 0.05s linear; /* Smooth width changes */
        }

        /* SVG for Outline View */
        #marketProfileContainer svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .mp-outline-path {
            stroke-width: 2px; /* Increased stroke width for better visibility */
            opacity: 0.7;
            transition: d 0.1s linear, fill 0.1s linear; /* Smooth path changes */
        }
        .mp-outline-buy {
            stroke: #60a5fa; /* Blue, matches original ticks */
            fill: rgba(96, 165, 250, 0.2); /* Light blue fill */
        }
        .mp-outline-sell {
            stroke: #EF4444; /* Red */
            fill: rgba(239, 68, 68, 0.2); /* Light red fill */
        }
    </style>
</head>
<body>
    <div class="main-container-wrapper">
        <!-- Main Visualization Area -->
        <main class="viz-wrapper">
            <div id="visualizationContainer" class="visualization-container">
                <!-- New wrapper for all core visualization elements -->
                <div id="visualizationsContentWrapper">
                    <div id="marketProfileContainer">
                        <!-- Market Profile Bars/SVG will be rendered here by JS -->
                    </div>
                    <div id="volatilityOrb"></div>
                    <!-- Removed: Distribution Dots Container -->
                    <div id="dayRangeMeter">
                        <!-- ADR steps will be rendered here by JS -->
                    </div>
                    <div id="priceFloat">
                        <!-- Removed: Pressure Arcs -->
                    </div>
                    <!-- Removed: Tick Pulse Container -->
                    <div id="maxDeflectionMarker"></div>
                </div>
                <!-- Price Display and Ripple Container remain outside visualizationsContentWrapper -->
                <div id="priceDisplay" class="absolute text-sm font-semibold text-gray-200"></div>
                <!-- Removed: Ripple Container -->
            </div>
        </main>

        <!-- Control Panel -->
        <aside class="w-full md:w-80 lg:w-96 p-4 overflow-y-auto control-panel">
            <h1 class="text-xl font-bold text-white mb-4">Adaptive Flow Meter</h1>
            <p class="text-sm text-gray-400 mb-6">Tune the simulation and visual feedback.</p>

            <div class="space-y-5">
                <!-- Simulation Controls -->
                <div>
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Simulation</h2>
                    <label class="control-label text-gray-300" for="frequencyMode">Market Activity</label>
                    <select id="frequencyMode" class="w-full p-2 rounded mt-1 text-sm">
                        <option value="calm">Calm</option>
                        <option value="normal" selected>Normal</option>
                        <option value="active">Active</option>
                        <option value="volatile">Volatile</option>
                    </select>
                </div>

                <!-- Meter Controls -->
                <div>
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Meter & Pulse</h2>
                    <!-- Renamed label to reflect new logic -->
                    <label class="control-label" for="meterWidth">Total Visualizations Width (px): <span id="meterWidthValue">120</span></label>
                    <input type="range" id="meterWidth" min="10" max="1000" value="220" class="w-full mt-1">
                    
                    <label class="control-label mt-3 block" for="centralAxisXPosition">Central Axis X Position (px): <span id="centralAxisXPositionValue">296</span></label>
                    <input type="range" id="centralAxisXPosition" min="50" max="992" value="170" class="w-full mt-1">

                    <label class="control-label mt-3 block" for="meterHeight">Meter Height (px): <span id="meterHeightValue">220</span></label>
                    <input type="range" id="meterHeight" min="50" max="500" value="120" class="w-full mt-1">
                    
                    <label class="control-label mt-3 block" for="adrRange">ADR (pips): <span id="adrRangeValue">100</span></label>
                    <input type="range" id="adrRange" min="20" max="300" value="100" class="w-full mt-1">
                    <label class="control-label mt-3 block" for="pulseThreshold">Pulse Threshold (pips): <span id="pulseThresholdValue">0.5</span></label>
                    <input type="range" id="pulseThreshold" min="0.1" max="5" step="0.1" value="0.5" class="w-full mt-1">
                    <label class="control-label mt-3 block" for="pulseScale">Pulse Scale (px/pip): <span id="pulseScaleValue">5</span></label>
                    <input type="range" id="pulseScale" min="1" max="20" value="5" class="w-full mt-1">
                </div>

                <!-- Event Highlighting -->
                <div>
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Event Highlighting</h2>
                    <label class="control-label" for="maxMarkerDecay">Max Marker Decay (s): <span id="maxMarkerDecayValue">10</span></label>
                    <input type="range" id="maxMarkerDecay" min="2" max="30" value="10" class="w-full mt-1">
                     <label class="control-label mt-3 block" for="adrProximityThreshold">ADR Proximity Threshold (%): <span id="adrProximityThresholdValue">10</span></label>
                    <input type="range" id="adrProximityThreshold" min="1" max="50" value="10" class="w-full mt-1">
                </div>
                
                <!-- Effect Toggles -->
                <div>
                     <h2 class="text-lg font-semibold text-blue-300 mb-3">Effect Toggles</h2>
                     <div class="space-y-2 text-sm">
                        <!-- Removed: Tick Pulse Toggle -->
                        <!-- Removed: Max Marker Toggle (kept feature due to decay control) -->
                        <!-- Removed: Distribution Dots Toggle -->
                        
                        <!-- Volatility Orb Toggle -->
                        <label class="toggle-label"><span>Volatility Orb</span><div class="toggle-switch"><input type="checkbox" id="toggleVolatilityOrb" checked><span class="toggle-slider"></span></div></label>
                        
                        <!-- Volatility Orb Color Mode Controls (initially hidden) -->
                        <div id="volatilityColorModeControls" class="ml-4 mt-2 space-y-2 text-xs" style="display: block;">
                            <h3 class="font-semibold text-gray-400">Color Mode:</h3>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="volatilityColorMode" value="directional">
                                    Directional (Default)
                                </label>
                                <label>
                                    <input type="radio" name="volatilityColorMode" value="intensity" checked>
                                    Intensity Spectrum
                                </label>
                                <label>
                                    <input type="radio" name="volatilityColorMode" value="singleHue">
                                    Single Hue (Purple)
                                </label>
                            </div>
                            <label class="control-label mt-3 block" for="volatilityOrbBaseWidth">Orb Base Width (px): <span id="volatilityOrbBaseWidthValue">120</span></label>
                            <input type="range" id="volatilityOrbBaseWidth" min="5" max="600" value="70" class="w-full mt-1">
                            
                            <!-- NEW: Volatility Orb Display Style Toggle -->
                            <label class="toggle-label mt-3"><span>Invert Brightness (Inward Growth)</span><div class="toggle-switch"><input type="checkbox" id="toggleVolatilityOrbInvertBrightness"><span class="toggle-slider"></span></div></label>
                        </div>

                        <!-- Removed: Pressure Arcs Toggle -->
                        <!-- Removed: Event Ripples Toggle -->
                        <label class="toggle-label"><span>Market Profile</span><div class="toggle-switch"><input type="checkbox" id="toggleMarketProfile" checked><span class="toggle-slider"></span></div></label>
                        
                        <!-- NEW: Flash on Significant Tick Toggle -->
                        <label class="toggle-label"><span>Flash on Significant Tick</span><div class="toggle-switch"><input type="checkbox" id="toggleFlash"><span class="toggle-slider"></span></div></label>
                        <label class="control-label mt-3 block" for="flashThreshold">Flash Threshold (pips): <span id="flashThresholdValue">5</span></label>
                        <input type="range" id="flashThreshold" min="2" max="20" value="2" class="w-full mt-1">
                        <label class="control-label mt-3 block" for="flashIntensity">Flash Intensity (0.0-1.0): <span id="flashIntensityValue">0.3</span></label>
                        <input type="range" id="flashIntensity" min="0.0" max="1.0" step="0.05" value="0.3" class="w-full mt-1">

                        <!-- NEW: Flash Volatility Orb Toggle -->
                        <label class="toggle-label mt-3"><span>Flash Volatility Orb</span><div class="toggle-switch"><input type="checkbox" id="toggleOrbFlash"><span class="toggle-slider"></span></div></label>
                        <label class="control-label mt-3 block" for="orbFlashThreshold">Orb Flash Threshold (pips): <span id="orbFlashThresholdValue">3</span></label>
                        <input type="range" id="orbFlashThreshold" min="1" max="15" value="2" class="w-full mt-1">
                        <label class="control-label mt-3 block" for="orbFlashIntensity">Orb Flash Intensity (0.0-1.0): <span id="orbFlashIntensityValue">0.8</span></label>
                        <input type="range" id="orbFlashIntensity" min="0.0" max="1.0" step="0.05" value="0.8" class="w-full mt-1">
                     </div>
                </div>

                <!-- Price Display Controls -->
                <div>
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Price Display</h2>
                    <label class="control-label" for="priceFontSize">Base Font Size (px): <span id="priceFontSizeValue">36</span></label>
                    <input type="range" id="priceFontSize" min="8" max="80" value="50" class="w-full mt-1">
                    
                    <label class="control-label mt-3 block" for="priceFontWeight">Font Weight</label>
                    <select id="priceFontWeight" class="w-full p-2 rounded mt-1 text-sm">
                        <option value="400">Normal</option>
                        <option value="500">Medium</option>
                        <option value="600" selected>Semibold</option>
                        <option value="700">Bold</option>
                    </select>

                    <label class="control-label mt-3 block" for="priceHorizontalOffset">Horizontal Offset (px): <span id="priceHorizontalOffsetValue">0</span></label>
                    <input type="range" id="priceHorizontalOffset" min="-200" max="200" value="14" class="w-full mt-1">

                    <!-- NEW: Price Bounding Box Toggle -->
                    <label class="toggle-label mt-3"><span>Price Bounding Box</span><div class="toggle-switch"><input type="checkbox" id="togglePriceBoundingBox"><span class="toggle-slider"></span></div></label>
                    <!-- NEW: Price Background Toggle -->
                    <label class="toggle-label mt-3"><span>Price Background</span><div class="toggle-switch"><input type="checkbox" id="togglePriceBackground"><span class="toggle-slider"></span></div></label>
                </div>

                <!-- Price Float & Digit Formatting Controls -->
                <div>
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Price Float & Digits</h2>
                    <label class="control-label" for="priceFloatWidth">Float Width (px): <span id="priceFloatWidthValue">8</span></label>
                    <input type="range" id="priceFloatWidth" min="2" max="200" value="50" class="w-full mt-1">
                    
                    <label class="control-label mt-3 block" for="priceFloatXOffset">Float X-Offset (px): <span id="priceFloatXOffsetValue">0</span></label>
                    <input type="range" id="priceFloatXOffset" min="-100" max="100" value="20" class="w-full mt-1">

                    <label class="control-label mt-3 block" for="bigFigureFontSizeRatio">Big Figure Size Ratio: <span id="bigFigureFontSizeRatioValue">1.2</span></label>
                    <input type="range" id="bigFigureFontSizeRatio" min="0.8" max="1.5" step="0.05" value="1.2" class="w-full mt-1">

                    <label class="control-label mt-3 block" for="pipFontSizeRatio">Pip Size Ratio: <span id="pipFontSizeRatioValue">1.1</span></label>
                    <input type="range" id="pipFontSizeRatio" min="0.8" max="1.5" step="0.05" value="1.1" class="w-full mt-1">

                    <!-- NEW: Pipette Digit Toggle -->
                    <label class="toggle-label mt-3"><span>Pipette Digit</span><div class="toggle-switch"><input type="checkbox" id="togglePipetteDigit" checked><span class="toggle-slider"></span></div></label>
                    <label class="control-label mt-3 block" for="pipetteFontSizeRatio">Pipette Size Ratio: <span id="pipetteFontSizeRatioValue">0.8</span></label>
                    <input type="range" id="pipetteFontSizeRatio" min="0.5" max="1.0" step="0.05" value="0.8" class="w-full mt-1">
                </div>

                <!-- Market Profile Controls -->
                <div id="marketProfileControls">
                    <h2 class="text-lg font-semibold text-blue-300 mb-3">Market Profile</h2>
                    <label class="control-label mt-3 block" for="distributionDepthMode">Distribution depth</label>
                    <select id="distributionDepthMode" class="w-full p-2 rounded mt-1 text-sm">
                        <option value="all">All (default)</option>
                        <option value="percentage">Last X%</option>
                    </select>
                    <div id="distributionPercentageContainer" class="mt-3" style="display: none;">
                        <label class="control-label block" for="distributionPercentage">Percentage: <span id="distributionPercentageValue">50</span>%</label>
                        <input type="range" id="distributionPercentage" min="10" max="100" value="50" step="5" class="w-full mt-1">
                    </div>
                    <div class="space-y-2 text-sm mt-3">
                        <label class="toggle-label"><span>Outline View</span><div class="toggle-switch"><input type="checkbox" id="toggleOutlineView" checked><span class="toggle-slider"></span></div></label>
                        <!-- NEW: Single-Sided Profile Toggle -->
                        <label class="toggle-label mt-3"><span>Single-Sided Profile</span><div class="toggle-switch"><input type="checkbox" id="toggleSingleSidedProfile"><span class="toggle-slider"></span></div></label>
                        <!-- NEW: Single-Sided Profile Side Controls (initially hidden) -->
                        <div id="singleSidedProfileSideControls" class="ml-4 mt-2 space-y-2 text-xs" style="display: none;">
                            <h3 class="font-semibold text-gray-400">Display Side:</h3>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="singleSidedProfileSide" value="left">
                                    Left
                                </label>
                                <label>
                                    <input type="radio" name="singleSidedProfileSide" value="right" checked>
                                    Right
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENT REFERENCES ---
    const vizWrapper = document.querySelector('.viz-wrapper'); // The overall canvas that can be resized
    const vizContainer = document.getElementById('visualizationContainer'); // Inner container, 100% of vizWrapper
    const visualizationsContentWrapper = document.getElementById('visualizationsContentWrapper'); // New: controls width of core viz elements
    const dayRangeMeter = document.getElementById('dayRangeMeter'); // Fixed-width central axis
    const priceFloat = document.getElementById('priceFloat');
    const priceDisplay = document.getElementById('priceDisplay');
    // Removed: tickPulseContainer, tickPulse, distributionContainer, pressureArcUp, pressureArcDown, rippleContainer
    const maxDeflectionMarker = document.getElementById('maxDeflectionMarker'); // Kept for Max Marker Decay control
    const volatilityOrb = document.getElementById('volatilityOrb');
    const marketProfileContainer = document.getElementById('marketProfileContainer');
    const marketProfileControls = document.getElementById('marketProfileControls');
    let adrBoundaryLines = []; // To store references to ADR boundary lines

    // Volatility Orb Color Mode Controls
    const toggleVolatilityOrb = document.getElementById('toggleVolatilityOrb');
    const volatilityColorModeControls = document.getElementById('volatilityColorModeControls');
    const volatilityColorModeRadios = document.querySelectorAll('input[name="volatilityColorMode"]');
    // Volatility Orb Invert Brightness Toggle
    const toggleVolatilityOrbInvertBrightness = document.getElementById('toggleVolatilityOrbInvertBrightness');
    // Flash on Significant Tick Toggle
    const toggleFlash = document.getElementById('toggleFlash');
    // Flash Volatility Orb Toggle
    const toggleOrbFlash = document.getElementById('toggleOrbFlash');
    // Price Display Bounding Box and Background Toggles
    const togglePriceBoundingBox = document.getElementById('togglePriceBoundingBox');
    const togglePriceBackground = document.getElementById('togglePriceBackground');
    // Pipette Digit Toggle
    const togglePipetteDigit = document.getElementById('togglePipetteDigit');
    // Market Profile Single-Sided Controls
    const toggleSingleSidedProfile = document.getElementById('toggleSingleSidedProfile');
    const singleSidedProfileSideControls = document.getElementById('singleSidedProfileSideControls');
    const singleSidedProfileSideRadios = document.querySelectorAll('input[name="singleSidedProfileSide"]');


    // --- CRITICAL ELEMENT CHECK ---
    // This block ensures all essential DOM elements are found before proceeding.
    // If any are null, it logs an error and stops script execution.
    // Added null checks for all critical DOM elements.
    if (!vizWrapper || !vizContainer || !visualizationsContentWrapper || !dayRangeMeter || !priceFloat || !priceDisplay || !maxDeflectionMarker || !volatilityOrb || !marketProfileContainer || !marketProfileControls || !toggleVolatilityOrb || !volatilityColorModeControls || !volatilityColorModeRadios || !toggleVolatilityOrbInvertBrightness || !toggleFlash || !toggleOrbFlash || !togglePriceBoundingBox || !togglePriceBackground || !togglePipetteDigit || !toggleSingleSidedProfile || !singleSidedProfileSideControls || !singleSidedProfileSideRadios) {
        console.error("One or more critical DOM elements not found. Please check HTML IDs.");
        console.log("vizWrapper:", vizWrapper);
        console.log("vizContainer:", vizContainer);
        console.log("visualizationsContentWrapper:", visualizationsContentWrapper);
        console.log("dayRangeMeter:", dayRangeMeter);
        console.log("priceFloat:", priceFloat);
        console.log("priceDisplay:", priceDisplay);
        console.log("maxDeflectionMarker:", maxDeflectionMarker);
        console.log("volatilityOrb:", volatilityOrb);
        console.log("marketProfileContainer:", marketProfileContainer);
        console.log("marketProfileControls:", marketProfileControls);
        console.log("toggleVolatilityOrb:", toggleVolatilityOrb);
        console.log("volatilityColorModeControls:", volatilityColorModeControls);
        console.log("volatilityColorModeRadios:", volatilityColorModeRadios);
        console.log("toggleVolatilityOrbInvertBrightness:", toggleVolatilityOrbInvertBrightness);
        console.log("toggleFlash:", toggleFlash);
        console.log("toggleOrbFlash:", toggleOrbFlash);
        console.log("togglePriceBoundingBox:", togglePriceBoundingBox);
        console.log("togglePriceBackground:", togglePriceBackground);
        console.log("togglePipetteDigit:", togglePipetteDigit);
        console.log("toggleSingleSidedProfile:", toggleSingleSidedProfile);
        console.log("singleSidedProfileSideControls:", singleSidedProfileSideControls);
        console.log("singleSidedProfileSideRadios:", singleSidedProfileSideRadios);
        return; // Stop script execution if critical elements are missing
    }

    // --- CONFIGURATION & STATE ---
    // Read initial values directly from HTML elements with null checks
    const config = {
        adrRange: parseFloat(document.getElementById('adrRange')?.value || '100'),
        pulseThreshold: parseFloat(document.getElementById('pulseThreshold')?.value || '0.5'),
        pulseScale: parseFloat(document.getElementById('pulseScale')?.value || '5'),
        maxMarkerDecay: parseInt(document.getElementById('maxMarkerDecay')?.value || '10'),
        flashThreshold: 2, // Updated value
        adrProximityThreshold: parseInt(document.getElementById('adrProximityThreshold')?.value || '10'),
        frequencyMode: document.getElementById('frequencyMode')?.value || 'normal',
        priceBucketSize: 0.5, // Fixed, not controlled by UI
        // Effect Toggles (read checked state)
        showMaxMarker: document.getElementById('toggleMaxMarker')?.checked || false, // Kept for Max Marker Decay control
        showVolatilityOrb: document.getElementById('toggleVolatilityOrb')?.checked || false,
        volatilityColorMode: document.querySelector('input[name="volatilityColorMode"]:checked')?.value || 'intensity',
        volatilityOrbBaseWidth: 70, // Updated value
        volatilityOrbInvertBrightness: document.getElementById('toggleVolatilityOrbInvertBrightness')?.checked || false,
        showMarketProfile: document.getElementById('toggleMarketProfile')?.checked || false,
        showFlash: document.getElementById('toggleFlash')?.checked || false, // NEW
        flashIntensity: parseFloat(document.getElementById('flashIntensity')?.value || '0.3'), // NEW
        showOrbFlash: document.getElementById('toggleOrbFlash')?.checked || false, // NEW
        orbFlashThreshold: 2, // Updated value
        orbFlashIntensity: parseFloat(document.getElementById('orbFlashIntensity')?.value || '0.8'), // NEW
        distributionDepthMode: document.getElementById('distributionDepthMode')?.value || 'all',
        distributionPercentage: parseInt(document.getElementById('distributionPercentage')?.value || '50'),
        marketProfileView: 'outline', // Updated value
        // Price Display Controls
        priceFontSize: 50, // Updated value
        priceFontWeight: document.getElementById('priceFontWeight')?.value || '600',
        priceHorizontalOffset: parseInt(document.getElementById('priceHorizontalOffset')?.value || '14'),
        // Price Float Controls
        priceFloatWidth: 50, // Updated value
        priceFloatXOffset: 20, // Updated value
        // Digit Font Size Ratios
        bigFigureFontSizeRatio: parseFloat(document.getElementById('bigFigureFontSizeRatio')?.value || '1.2'),
        pipFontSizeRatio: parseFloat(document.getElementById('pipFontSizeRatio')?.value || '1.1'),
        pipetteFontSizeRatio: parseFloat(document.getElementById('pipetteFontSizeRatio')?.value || '0.8'), // Re-enabled
        // NEW: Price Display Bounding Box and Background
        showPriceBoundingBox: document.getElementById('togglePriceBoundingBox')?.checked || false,
        showPriceBackground: document.getElementById('togglePriceBackground')?.checked || false,
        priceDisplayPadding: 4, // px, for bounding box/background
        // Meter Dimensions
        visualizationsContentWidth: 220, // Updated value
        centralAxisXPosition: 170, // Updated value
        meterHeight: 120, // Updated value
        centralMeterFixedThickness: 8, // Fixed in CSS
        // NEW: Pipette digit toggle
        showPipetteDigit: document.getElementById('togglePipetteDigit')?.checked || false,
        // NEW: Market Profile Single-Sided Controls
        showSingleSidedProfile: document.getElementById('toggleSingleSidedProfile')?.checked || false,
        singleSidedProfileSide: document.querySelector('input[name="singleSidedProfileSide"]:checked')?.value || 'right',
    };


    const frequencySettings = {
        calm: {
            baseInterval: 2000,
            randomness: 1500,
            magnitudeMultiplier: 0.5,
            momentumStrength: 0.05, // New parameter for momentum
            meanReversionPoint: 0.7 // New parameter for mean reversion
        },
        normal: {
            baseInterval: 800,
            randomness: 1000,
            magnitudeMultiplier: 1,
            momentumStrength: 0.1,
            meanReversionPoint: 0.7
        },
        active: {
            baseInterval: 300,
            randomness: 400,
            magnitudeMultiplier: 1.5,
            momentumStrength: 0.15,
            meanReversionPoint: 0.6
        },
        volatile: {
            baseInterval: 100,
            randomness: 200,
            magnitudeMultiplier: 2,
            momentumStrength: 0.2,
            meanReversionPoint: 0.5
        },
    };

    const state = {
        currentPrice: 1.25500, // Current simulated price
        midPrice: 1.25500, // Center of the ADR range, adjusts with price
        lastTickTime: 0,
        ticks: [], // Short-term ticks for volatility/pulse
        allTicks: [], // Long-term ticks for market profile distribution
        minObservedPrice: Infinity, // Track min price for dynamic ADR
        maxObservedPrice: -Infinity, // Track max price for dynamic ADR
        maxDeflection: { up: 0, down: 0, lastUpdateTime: 0 }, // Max price deflection
        pressure: { up: 0, down: 0 }, // Buy/Sell pressure accumulation
        volatility: 0, // Calculated market volatility
        lastTickDirection: 0, // To store the direction of the last tick for price display
        momentum: 0, // Initialize momentum state for the new logic
        isOrbFlashing: false, // NEW: State to track if the orb is currently flashing
    };

    // --- CONTROL PANEL WIRING ---
    const controls = {
        adrRange: document.getElementById('adrRange'),
        pulseThreshold: document.getElementById('pulseThreshold'),
        pulseScale: document.getElementById('pulseScale'),
        maxMarkerDecay: document.getElementById('maxMarkerDecay'),
        flashThreshold: document.getElementById('flashThreshold'),
        adrProximityThreshold: document.getElementById('adrProximityThreshold'), // New control for ADR proximity
        frequencyMode: document.getElementById('frequencyMode'),
        // Toggles
        // Removed: toggleTickPulse, toggleDistDots, togglePressureArcs, toggleEventRipples
        toggleMaxMarker: document.getElementById('toggleMaxMarker'), // Kept for Max Marker Decay control
        toggleVolatilityOrb: toggleVolatilityOrb, // Reference to the existing toggle
        volatilityColorModeControls: volatilityColorModeControls, // Reference to the new div
        volatilityColorModeRadios: volatilityColorModeRadios, // Reference to the radio buttons
        volatilityOrbBaseWidth: document.getElementById('volatilityOrbBaseWidth'), // New control for orb base width
        toggleVolatilityOrbInvertBrightness: toggleVolatilityOrbInvertBrightness, // NEW
        toggleMarketProfile: document.getElementById('toggleMarketProfile'),
        toggleFlash: document.getElementById('toggleFlash'), // NEW
        flashIntensity: document.getElementById('flashIntensity'), // NEW
        toggleOrbFlash: document.getElementById('toggleOrbFlash'), // NEW
        orbFlashThreshold: document.getElementById('orbFlashThreshold'), // NEW
        orbFlashIntensity: document.getElementById('orbFlashIntensity'), // NEW
        distributionDepthMode: document.getElementById('distributionDepthMode'),
        distributionPercentage: document.getElementById('distributionPercentage'),
        distributionPercentageContainer: document.getElementById('distributionPercentageContainer'),
        toggleOutlineView: document.getElementById('toggleOutlineView'),
        // Price Display Controls
        priceFontSize: document.getElementById('priceFontSize'),
        priceFontWeight: document.getElementById('priceFontWeight'),
        priceHorizontalOffset: document.getElementById('priceHorizontalOffset'),
        // NEW: Price Display Bounding Box and Background
        togglePriceBoundingBox: togglePriceBoundingBox,
        togglePriceBackground: togglePriceBackground,
        // Price Float Controls
        priceFloatWidth: document.getElementById('priceFloatWidth'),
        priceFloatXOffset: document.getElementById('priceFloatXOffset'),
        // Digit Font Size Ratios
        bigFigureFontSizeRatio: document.getElementById('bigFigureFontSizeRatio'),
        pipFontSizeRatio: document.getElementById('pipFontSizeRatio'),
        pipetteFontSizeRatio: document.getElementById('pipetteFontSizeRatio'), // Re-enabled
        // NEW: Pipette digit toggle
        togglePipetteDigit: togglePipetteDigit,
        // Meter Dimension Controls (re-purposed)
        meterWidth: document.getElementById('meterWidth'), // Now controls visualizationsContentWidth
        centralAxisXPosition: document.getElementById('centralAxisXPosition'), // New control for central axis X position
        meterHeight: document.getElementById('meterHeight'), // Controls central meter's height
        // NEW: Market Profile Single-Sided Controls
        toggleSingleSidedProfile: toggleSingleSidedProfile,
        singleSidedProfileSideControls: singleSidedProfileSideControls,
        singleSidedProfileSideRadios: singleSidedProfileSideRadios,
    };

    const valueSpans = {
        adrRangeValue: document.getElementById('adrRangeValue'),
        pulseThresholdValue: document.getElementById('pulseThresholdValue'),
        pulseScaleValue: document.getElementById('pulseScaleValue'),
        maxMarkerDecayValue: document.getElementById('maxMarkerDecayValue'),
        flashThresholdValue: document.getElementById('flashThresholdValue'),
        adrProximityThresholdValue: document.getElementById('adrProximityThresholdValue'), // New value span for ADR proximity
        distributionPercentageValue: document.getElementById('distributionPercentageValue'),
        // Price Display Value Spans
        priceFontSizeValue: document.getElementById('priceFontSizeValue'),
        priceHorizontalOffsetValue: document.getElementById('priceHorizontalOffsetValue'),
        // Price Float Value Spans
        priceFloatWidthValue: document.getElementById('priceFloatWidthValue'),
        priceFloatXOffsetValue: document.getElementById('priceFloatXOffsetValue'),
        // NEW: Digit Font Size Value Spans
        bigFigureFontSizeRatioValue: document.getElementById('bigFigureFontSizeRatioValue'),
        pipFontSizeRatioValue: document.getElementById('pipFontSizeRatioValue'),
        pipetteFontSizeRatioValue: document.getElementById('pipetteFontSizeRatioValue'), // Re-enabled
        // Meter Dimension Value Spans (re-purposed)
        meterWidthValue: document.getElementById('meterWidthValue'), // Now displays visualizationsContentWidth
        centralAxisXPositionValue: document.getElementById('centralAxisXPositionValue'), // New value span for central axis X position
        meterHeightValue: document.getElementById('meterHeightValue'), // Displays central meter's height
        volatilityOrbBaseWidthValue: document.getElementById('volatilityOrbBaseWidthValue'), // New value span for orb base width
        flashIntensityValue: document.getElementById('flashIntensityValue'), // NEW
        orbFlashThresholdValue: document.getElementById('orbFlashThresholdValue'), // NEW
        orbFlashIntensityValue: document.getElementById('orbFlashIntensityValue'), // NEW
    };

    /**
     * Sets up event listeners for all control panel elements.
     */
    function setupControls() {
        // Handle sliders and selects for general config
        ['adrRange', 'pulseThreshold', 'pulseScale', 'maxMarkerDecay', 'flashIntensity', 'orbFlashIntensity', 'pipetteFontSizeRatio'].forEach(key => { // Added pipetteFontSizeRatio
            if (controls[key]) { // Add null check for controls element
                controls[key].addEventListener('input', (e) => {
                    const value = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value;
                    config[key] = value;
                    if (valueSpans[key + 'Value']) {
                        valueSpans[key + 'Value'].textContent = value;
                    }
                    updateAllDependentElements();
                });
            }
        });

        // Handle hardcoded values for sliders that are now fixed in config
        if (controls.flashThreshold) { // Add null check
            controls.flashThreshold.addEventListener('input', (e) => {
                config.flashThreshold = parseInt(e.target.value);
                if (valueSpans.flashThresholdValue) valueSpans.flashThresholdValue.textContent = config.flashThreshold;
                updateAllDependentElements();
            });
        }
        if (controls.orbFlashThreshold) { // Add null check
            controls.orbFlashThreshold.addEventListener('input', (e) => {
                config.orbFlashThreshold = parseInt(e.target.value);
                if (valueSpans.orbFlashThresholdValue) valueSpans.orbFlashThresholdValue.textContent = config.orbFlashThreshold;
                updateAllDependentElements();
            });
        }
        if (controls.frequencyMode) { // Add null check
            controls.frequencyMode.addEventListener('input', (e) => {
                config.frequencyMode = e.target.value;
                updateAllDependentElements();
            });
        }
        if (controls.adrProximityThreshold) { // Add null check
            controls.adrProximityThreshold.addEventListener('input', (e) => {
                config.adrProximityThreshold = parseInt(e.target.value);
                if (valueSpans.adrProximityThresholdValue) valueSpans.adrProximityThresholdValue.textContent = config.adrProximityThreshold;
                updateAllDependentElements();
            });
        }


        // Handle "Total Visualizations Width" control
        if (controls.meterWidth) { // Add null check
            controls.meterWidth.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                config.visualizationsContentWidth = value; // Update the new config property
                if (valueSpans.meterWidthValue) valueSpans.meterWidthValue.textContent = value;
                visualizationsContentWrapper.style.width = `${value}px`; // Directly control visualizationsContentWrapper width
                // Update the max value of centralAxisXPosition slider
                if (controls.centralAxisXPosition) controls.centralAxisXPosition.max = value - config.centralMeterFixedThickness;
                // Update max value for volatilityOrbBaseWidth to prevent it from exceeding total width
                if (controls.volatilityOrbBaseWidth) controls.volatilityOrbBaseWidth.max = value;
                updateAllDependentElements();
            });
        }

        // Handle "Central Axis X Position" control
        if (controls.centralAxisXPosition) { // Add null check
            controls.centralAxisXPosition.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                config.centralAxisXPosition = value;
                if (valueSpans.centralAxisXPositionValue) valueSpans.centralAxisXPositionValue.textContent = value;
                updateAllDependentElements();
            });
        }

        // Handle "Meter Height" control (for the central meter)
        if (controls.meterHeight) { // Add null check
            controls.meterHeight.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                config.meterHeight = value; // Update the central meter's height config
                if (valueSpans.meterHeightValue) valueSpans.meterHeightValue.textContent = value;
                // The dayRangeMeter's height is set in setupDayRangeMeter, which is called by updateAllDependentElements
                updateAllDependentElements();
            });
        }

        // Handle toggles for effects visibility
        ['MaxMarker', 'MarketProfile', 'Flash', 'OrbFlash'].forEach(name => { // MaxMarker kept for its decay control
            const key = `show${name}`;
            const toggleKey = `toggle${name}`;
            if (controls[toggleKey]) { // Check if the toggle element exists
                controls[toggleKey].addEventListener('change', (e) => {
                    config[key] = e.target.checked;
                    updateElementVisibility(); // Apply visibility change
                });
            }
        });

        // Volatility Orb toggle and color mode controls
        if (controls.toggleVolatilityOrb) { // Add null check
            controls.toggleVolatilityOrb.addEventListener('change', (e) => {
                config.showVolatilityOrb = e.target.checked;
                if (volatilityColorModeControls) volatilityColorModeControls.style.display = config.showVolatilityOrb ? 'block' : 'none';
                updateElementVisibility(); // Apply visibility change for the orb itself
            });
        }

        if (controls.volatilityColorModeRadios) { // Add null check
            controls.volatilityColorModeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    config.volatilityColorMode = e.target.value;
                    renderVolatilityOrb(); // Re-render orb with new color mode
                });
            });
        }

        // New: Volatility Orb Base Width control
        if (controls.volatilityOrbBaseWidth) { // Add null check
            controls.volatilityOrbBaseWidth.addEventListener('input', (e) => {
                config.volatilityOrbBaseWidth = parseInt(e.target.value);
                if (valueSpans.volatilityOrbBaseWidthValue) valueSpans.volatilityOrbBaseWidthValue.textContent = config.volatilityOrbBaseWidth;
                renderVolatilityOrb(); // Re-render orb with new base width
            });
        }

        // NEW: Volatility Orb Invert Brightness toggle
        if (controls.toggleVolatilityOrbInvertBrightness) { // Add null check
            controls.toggleVolatilityOrbInvertBrightness.addEventListener('change', (e) => {
                config.volatilityOrbInvertBrightness = e.target.checked;
                renderVolatilityOrb(); // Re-render orb with new display style
            });
        }

        // Handle Market Profile specific controls
        if (controls.distributionDepthMode) { // Add null check
            controls.distributionDepthMode.addEventListener('change', (e) => {
                config.distributionDepthMode = e.target.value;
                if (controls.distributionPercentageContainer) { // Add null check
                    if (config.distributionDepthMode === 'percentage') {
                        controls.distributionPercentageContainer.style.display = 'block';
                    } else {
                        controls.distributionPercentageContainer.style.display = 'none';
                    }
                }
                renderMarketProfile(); // Re-render profile when view changes
            });
        }

        if (controls.distributionPercentage) { // Add null check
            controls.distributionPercentage.addEventListener('input', (e) => {
                config.distributionPercentage = parseInt(e.target.value);
                if (valueSpans.distributionPercentageValue) valueSpans.distributionPercentageValue.textContent = config.distributionPercentage;
                renderMarketProfile(); // Re-render profile when percentage changes
            });
        }

        if (controls.toggleOutlineView) { // Add null check
            controls.toggleOutlineView.addEventListener('change', (e) => {
                config.marketProfileView = e.target.checked ? 'outline' : 'bars';
                renderMarketProfile(); // Re-render profile when view changes
            });
        }

        // NEW: Single-Sided Profile Toggle
        if (controls.toggleSingleSidedProfile) { // Add null check
            controls.toggleSingleSidedProfile.addEventListener('change', (e) => {
                config.showSingleSidedProfile = e.target.checked;
                if (singleSidedProfileSideControls) singleSidedProfileSideControls.style.display = config.showSingleSidedProfile ? 'block' : 'none';
                renderMarketProfile(); // Re-render when this changes
            });
        }

        // NEW: Single-Sided Profile Side Radios
        if (controls.singleSidedProfileSideRadios) { // Add null check
            controls.singleSidedProfileSideRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    config.singleSidedProfileSide = e.target.value;
                    renderMarketProfile(); // Re-render when this changes
                });
            });
        }


        // Handle price display controls
        if (controls.priceFontSize) { // Add null check
            controls.priceFontSize.addEventListener('input', (e) => {
                config.priceFontSize = parseFloat(e.target.value);
                if (valueSpans.priceFontSizeValue) valueSpans.priceFontSizeValue.textContent = config.priceFontSize;
                updatePriceDisplayStyles(); // This will now correctly set the base font size
            });
        }
        if (controls.priceFontWeight) { // Add null check
            controls.priceFontWeight.addEventListener('change', (e) => {
                config.priceFontWeight = e.target.value;
                updatePriceDisplayStyles();
            });
        }
        if (controls.priceHorizontalOffset) { // Add null check
            controls.priceHorizontalOffset.addEventListener('input', (e) => {
                config.priceHorizontalOffset = parseInt(e.target.value);
                if (valueSpans.priceHorizontalOffsetValue) valueSpans.priceHorizontalOffsetValue.textContent = config.priceHorizontalOffset;
                updatePriceDisplayStyles();
            });
        }
        // NEW: Price Bounding Box and Background Toggles
        if (controls.togglePriceBoundingBox) { // Add null check
            controls.togglePriceBoundingBox.addEventListener('change', (e) => {
                config.showPriceBoundingBox = e.target.checked;
                updatePriceDisplayStyles();
            });
        }
        if (controls.togglePriceBackground) { // Add null check
            controls.togglePriceBackground.addEventListener('change', (e) => {
                config.showPriceBackground = e.target.checked;
                updatePriceDisplayStyles();
            });
        }
        // NEW: Pipette Digit Toggle
        if (controls.togglePipetteDigit) { // Add null check
            controls.togglePipetteDigit.addEventListener('change', (e) => {
                config.showPipetteDigit = e.target.checked;
                updateDayRangeMeter({ direction: state.lastTickDirection, magnitude: 0 }); // Re-render price string
            });
        }

        // Handle price float width and x-offset controls
        if (controls.priceFloatWidth) { // Add null check
            controls.priceFloatWidth.addEventListener('input', (e) => {
                config.priceFloatWidth = parseInt(e.target.value);
                if (valueSpans.priceFloatWidthValue) valueSpans.priceFloatWidthValue.textContent = config.priceFloatWidth;
                updateAllDependentElements(); // Recalculate positions based on new width
            });
        }
        if (controls.priceFloatXOffset) { // Add null check
            controls.priceFloatXOffset.addEventListener('input', (e) => {
                config.priceFloatXOffset = parseInt(e.target.value);
                if (valueSpans.priceFloatXOffsetValue) valueSpans.priceFloatXOffsetValue.textContent = config.priceFloatXOffset;
                updateAllDependentElements(); // Recalculate positions based on new offset
            });
        }

        // NEW: Handle digit font size ratio controls - NOW CALLS updateAllDependentElements
        ['bigFigureFontSizeRatio', 'pipFontSizeRatio', 'pipetteFontSizeRatio'].forEach(key => { // Added pipetteFontSizeRatio here
            if (controls[key]) { // Add null check
                controls[key].addEventListener('input', (e) => {
                    config[key] = parseFloat(e.target.value);
                    if (valueSpans[key + 'Value']) valueSpans[key + 'Value'].textContent = config[key];
                    // Update CSS custom properties on priceDisplay
                    priceDisplay.style.setProperty(`--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`, config[key]);
                    updateAllDependentElements(); // Crucial: trigger full update
                });
            }
        });

        // Initialize display values for sliders that now control different things
        if (valueSpans.meterWidthValue) valueSpans.meterWidthValue.textContent = config.visualizationsContentWidth;
        if (valueSpans.centralAxisXPositionValue) valueSpans.centralAxisXPositionValue.textContent = config.centralAxisXPosition;
        if (valueSpans.meterHeightValue) valueSpans.meterHeightValue.textContent = config.meterHeight;
        if (valueSpans.adrProximityThresholdValue) valueSpans.adrProximityThresholdValue.textContent = config.adrProximityThreshold; // Initialize new slider value
        if (valueSpans.priceFloatWidthValue) valueSpans.priceFloatWidthValue.textContent = config.priceFloatWidth; // Initialize new price float width value
        if (valueSpans.priceFloatXOffsetValue) valueSpans.priceFloatXOffsetValue.textContent = config.priceFloatXOffset; // Initialize new price float x-offset value
        // Initialize new digit font size ratio values
        if (valueSpans.bigFigureFontSizeRatioValue) valueSpans.bigFigureFontSizeRatioValue.textContent = config.bigFigureFontSizeRatio;
        if (valueSpans.pipFontSizeRatioValue) valueSpans.pipFontSizeRatioValue.textContent = config.pipFontSizeRatio;
        if (valueSpans.pipetteFontSizeRatioValue) valueSpans.pipetteFontSizeRatioValue.textContent = config.pipetteFontSizeRatio; // Re-enabled
        if (valueSpans.volatilityOrbBaseWidthValue) valueSpans.volatilityOrbBaseWidthValue.textContent = config.volatilityOrbBaseWidth; // New value span for orb base width
        if (valueSpans.flashIntensityValue) valueSpans.flashIntensityValue.textContent = config.flashIntensity; // NEW
        if (valueSpans.orbFlashThresholdValue) valueSpans.orbFlashThresholdValue.textContent = config.orbFlashThreshold; // NEW
        if (valueSpans.orbFlashIntensityValue) valueSpans.orbFlashIntensityValue.textContent = config.orbFlashIntensity; // NEW
        
        // Set initial state for volatility color mode radios
        const volatilityRadio = document.querySelector(`input[name="volatilityColorMode"][value="${config.volatilityColorMode}"]`);
        if (volatilityRadio) {
            volatilityRadio.checked = true;
        }
        if (volatilityColorModeControls) volatilityColorModeControls.style.display = config.showVolatilityOrb ? 'block' : 'none';

        // Set initial toggle for Invert Brightness
        if (controls.toggleVolatilityOrbInvertBrightness) {
            controls.toggleVolatilityOrbInvertBrightness.checked = config.volatilityOrbInvertBrightness;
        }

        // Set initial max for centralAxisXPosition slider
        if (controls.centralAxisXPosition) {
            controls.centralAxisXPosition.max = config.visualizationsContentWidth - config.centralMeterFixedThickness;
        }
        // Set initial max for volatilityOrbBaseWidth slider
        if (controls.volatilityOrbBaseWidth) {
            controls.volatilityOrbBaseWidth.max = config.visualizationsContentWidth;
        }

        // Set initial toggle states
        if (controls.toggleMaxMarker) {
            controls.toggleMaxMarker.checked = config.showMaxMarker; // Kept for Max Marker Decay control
        }
        if (controls.toggleMarketProfile) {
            controls.toggleMarketProfile.checked = config.showMarketProfile;
        }
        if (controls.toggleFlash) {
            controls.toggleFlash.checked = config.showFlash; // NEW
        }
        if (controls.toggleOrbFlash) {
            controls.toggleOrbFlash.checked = config.showOrbFlash; // NEW
        }
        if (controls.toggleOutlineView) {
            controls.toggleOutlineView.checked = (config.marketProfileView === 'outline'); // Set outline view toggle
        }
        // Set initial toggle states for new price display options
        if (controls.togglePriceBoundingBox) {
            controls.togglePriceBoundingBox.checked = config.showPriceBoundingBox;
        }
        if (controls.togglePriceBackground) {
            controls.togglePriceBackground.checked = config.showPriceBackground;
        }
        // Set initial toggle state for pipette digit
        if (controls.togglePipetteDigit) {
            controls.togglePipetteDigit.checked = config.showPipetteDigit;
        }
        // NEW: Initialize single-sided profile toggle and radio buttons
        if (controls.toggleSingleSidedProfile) {
            controls.toggleSingleSidedProfile.checked = config.showSingleSidedProfile;
        }
        if (singleSidedProfileSideControls) singleSidedProfileSideControls.style.display = config.showSingleSidedProfile ? 'block' : 'none';
        const singleSidedRadio = document.querySelector(`input[name="singleSidedProfileSide"][value="${config.singleSidedProfileSide}"]`);
        if (singleSidedRadio) {
            singleSidedRadio.checked = true;
        }
    }

    /**
     * Updates the display style of various visualization elements based on config toggles.
     */
    function updateElementVisibility() {
        // Removed: tickPulseContainer, distributionContainer, pressureArcUp, pressureArcDown, rippleContainer
        if (maxDeflectionMarker) maxDeflectionMarker.style.display = config.showMaxMarker ? 'block' : 'none'; // Kept for Max Marker Decay control
        if (volatilityOrb) volatilityOrb.style.display = config.showVolatilityOrb ? 'block' : 'none'; // Controlled by its own toggle
        if (marketProfileContainer) marketProfileContainer.style.display = config.showMarketProfile ? 'block' : 'none';
        if (marketProfileControls) marketProfileControls.style.display = config.showMarketProfile ? 'block' : 'none';
        if (controls.distributionPercentageContainer) { // Add null check
            if (config.distributionDepthMode === 'percentage') {
                controls.distributionPercentageContainer.style.display = 'block';
            } else {
                controls.distributionPercentageContainer.style.display = 'none';
            }
        }
    }

    /**
     * Applies the current font size, font weight, and horizontal offset to the price display.
     */
    function updatePriceDisplayStyles() {
        // Defensive check: Ensure priceDisplay is not null before proceeding
        if (!priceDisplay) {
            console.error("Error: priceDisplay element is null. Cannot update styles.");
            return; // Exit the function to prevent further errors
        }

        priceDisplay.style.fontSize = `${config.priceFontSize}px`;
        priceDisplay.style.fontWeight = config.priceFontWeight;
        
        // Reset background and border styles first
        priceDisplay.style.border = 'none';
        priceDisplay.style.borderRadius = '0';
        priceDisplay.style.backgroundColor = 'transparent';
        // Reset padding
        priceDisplay.style.paddingTop = '0';
        priceDisplay.style.paddingBottom = '0';
        priceDisplay.style.paddingLeft = '0';
        priceDisplay.style.paddingRight = '0'; // Ensure this is reset too

        // Apply padding if bounding box or background is enabled
        if (config.showPriceBoundingBox || config.showPriceBackground) {
            priceDisplay.style.paddingTop = `${config.priceDisplayPadding}px`;
            priceDisplay.style.paddingBottom = `${config.priceDisplayPadding}px`;
            priceDisplay.style.paddingLeft = `${config.priceDisplayPadding}px`;
            priceDisplay.style.paddingRight = `${config.priceDisplayPadding}px`; 
        }


        if (config.showPriceBoundingBox) {
            priceDisplay.style.border = '1px solid #4b5563';
            priceDisplay.style.borderRadius = '4px';
        }

        if (config.showPriceBackground) {
            priceDisplay.style.backgroundColor = 'rgba(17, 24, 39, 0.7)';
        }

        // Calculate priceDisplay's left position relative to the priceFloat's left edge
        // The priceFloat's actual left edge:
        const priceFloatActualLeft = config.centralAxisXPosition + (config.centralMeterFixedThickness / 2) - (config.priceFloatWidth / 2) + config.priceFloatXOffset;
        
        // The priceDisplay's right edge should be positioned relative to priceFloatActualLeft.
        // The `config.priceHorizontalOffset` is the gap between the right edge of the price display and the left edge of the float.
        // So, priceDisplay.style.left = (priceFloatActualLeft - config.priceHorizontalOffset) - priceDisplay.offsetWidth;
        // Re-evaluate the left positioning to ensure it's calculated after all content is rendered and has its width
        // This will be called again after innerHTML is set in updateDayRangeMeter.
        // For now, setting it to an initial value that will be updated.
        priceDisplay.style.left = `${priceFloatActualLeft - config.priceHorizontalOffset - priceDisplay.offsetWidth}px`;


        // Update CSS custom properties for digit font sizes
        priceDisplay.style.setProperty('--big-figure-font-size-ratio', config.bigFigureFontSizeRatio);
        priceDisplay.style.setProperty('--pip-font-size-ratio', config.pipFontSizeRatio);
        priceDisplay.style.setProperty('--pipette-font-size-ratio', config.pipetteFontSizeRatio); // Re-enabled
    }

    // --- INITIAL SETUP ---
    /**
     * Sets up the ADR meter's dimensions and adds static step markers.
     * Uses config.meterHeight for central meter height, and config.visualizationsContentWidth for visualizationsContentWrapper width.
     */
    function setupDayRangeMeter() {
        // Set the width of the visualizations content wrapper
        if (visualizationsContentWrapper) visualizationsContentWrapper.style.width = `${config.visualizationsContentWidth}px`;
        // Set the central meter's height (its width is fixed in CSS)
        if (dayRangeMeter) dayRangeMeter.style.height = `${config.meterHeight}px`;
        // Set the central meter's X position
        if (dayRangeMeter) dayRangeMeter.style.left = `${config.centralAxisXPosition}px`;

        // Clear existing markers before adding new ones
        // We'll remove all .adr-step elements that are direct children of visualizationsContentWrapper
        if (visualizationsContentWrapper) {
            visualizationsContentWrapper.querySelectorAll('.adr-step').forEach(marker => marker.remove());
        }


        const adrStepsContainer = document.createDocumentFragment();
        // Add markers at 25%, 50%, 75% of the ADR range relative to meter's height
        [0.25, 0.5, 0.75].forEach(step => {
            const marker = document.createElement('div');
            marker.className = 'adr-step';

            // Calculate marker's top position relative to visualizationsContentWrapper
            // This centers the marker vertically on the corresponding point of the meter
            const markerHeight = 2; // From CSS
            const centralMeterTopOffsetInWrapper = (visualizationsContentWrapper.offsetHeight / 2) - (dayRangeMeter.offsetHeight / 2);
            marker.style.top = `${centralMeterTopOffsetInWrapper + (1 - step) * dayRangeMeter.offsetHeight - (markerHeight / 2)}px`;

            // Calculate marker's left position to center it horizontally on the meter
            const markerWidth = 16; // From CSS
            const centralMeterLeftEdge = config.centralAxisXPosition;
            marker.style.left = `${centralMeterLeftEdge + (config.centralMeterFixedThickness / 2) - (markerWidth / 2)}px`;

            if (visualizationsContentWrapper) visualizationsContentWrapper.appendChild(marker); // Append to wrapper for z-index control
        });
        
        // Add ADR boundary lines to the visualization container (these span full container width)
        // Clear existing boundary lines first and clear the adrBoundaryLines array
        adrBoundaryLines.forEach(line => line.remove());
        adrBoundaryLines = [];

        // Calculate central meter's top offset within the vizContainer (based on its fixed center)
        const centralMeterTopOffset = (vizContainer.offsetHeight / 2) - (dayRangeMeter.offsetHeight / 2);

        const topADRLine = document.createElement('div');
        topADRLine.className = 'adr-boundary-line';
        topADRLine.style.top = `${centralMeterTopOffset}px`; // Position relative to the top of the meter within the container
        if (vizContainer) vizContainer.appendChild(topADRLine);
        adrBoundaryLines.push(topADRLine);

        const bottomADRLine = document.createElement('div');
        bottomADRLine.className = 'adr-boundary-line';
        bottomADRLine.style.top = `${centralMeterTopOffset + dayRangeMeter.offsetHeight - 2}px`; // Position relative to the bottom of the meter within the container (-2 for line height)
        if (vizContainer) vizContainer.appendChild(bottomADRLine);
        adrBoundaryLines.push(bottomADRLine);
    }

    // --- TICK SIMULATOR ---
    /**
     * Generates a new simulated price tick based on frequency mode.
     */
    function generateTick() {
        const now = performance.now();
        const settings = frequencySettings[config.frequencyMode];

        if (now - state.lastTickTime < (settings.baseInterval + (Math.random() * settings.randomness))) return;

        // Momentum decay toward neutral
        state.momentum = (state.momentum || 0) * 0.85; // Decay factor

        // Calculate bias
        let bias = state.momentum * settings.momentumStrength;

        // Mean reversion kick-in
        if (Math.abs(state.momentum) > settings.meanReversionPoint) {
            bias *= -0.5; // Reverse the bias
        }
        
        // Apply the bias to determine direction
        const direction = Math.random() < (0.5 + bias) ? 1 : -1;

        // Update momentum (strengthen if same direction, weaken if opposite)
        state.momentum = Math.max(-1, Math.min(1, state.momentum + direction * 0.25));

        const rand = Math.random();
        let magnitude = (rand < 0.8) ? Math.random() * 0.8 : (rand < 0.98) ? 0.8 + Math.random() * 2 : 3 + Math.random() * 5;
        magnitude *= settings.magnitudeMultiplier;

        const tick = {
            magnitude: parseFloat(magnitude.toFixed(1)),
            direction: direction,
            price: state.currentPrice + (direction * magnitude / 10000)
        };
        
        state.currentPrice = tick.price;
        state.lastTickTime = now;
        processTick(tick);
    }

    // --- TICK PROCESSING & UI UPDATES ---
    /**
     * Processes a new tick, updating various visualization components.
     */
    function processTick(tick) {
        state.ticks.push({ ...tick, time: performance.now() });
        state.allTicks.push({ ...tick, time: performance.now() });

        state.minObservedPrice = Math.min(state.minObservedPrice, state.currentPrice);
        state.maxObservedPrice = Math.max(state.maxObservedPrice, state.currentPrice);
        state.lastTickDirection = tick.direction; // Store last tick direction for price display

        updateDayRangeMeter(tick);
        
        if (tick.magnitude >= config.pulseThreshold) {
            // Removed: if (config.showTickPulse) updateTickPulse(tick);
            // Removed: if (config.showDistDots) createDistributionDot(tick);
        }
        if (config.showMaxMarker) updateMaxDeflection(tick);
        // Removed: if (config.showPressureArcs) updatePressure(tick);
        // Removed: if (config.showEventRipples && tick.magnitude >= 3) createEventRipple(tick);
        if (config.showFlash && tick.magnitude >= config.flashThreshold) flashMeter(tick.direction);
        if (config.showOrbFlash && tick.magnitude >= config.orbFlashThreshold) flashVolatilityOrb(tick.direction); // NEW: Conditional orb flash

        checkADRProximity(); // Check ADR proximity after price update
    }

    /**
     * Updates the position and color of the price float on the ADR meter.
     * Also handles the new price formatting.
     * (Linked to: "Prioritize Preattentive Cues for Critical FX Signals", "Consistent Color Usage", "Accessibility")
     */
    function updateDayRangeMeter(tick) {
        const observedRange = state.maxObservedPrice - state.minObservedPrice;
        const effectiveADRInPrice = Math.max(config.adrRange / 10000, observedRange * 1.1);
        
        const currentPriceOffsetFromMid = state.currentPrice - state.midPrice;
        const halfEffectiveADR = effectiveADRInPrice / 2;

        if (currentPriceOffsetFromMid > halfEffectiveADR) {
            state.midPrice = state.currentPrice - halfEffectiveADR;
        } else if (currentPriceOffsetFromMid < -halfEffectiveADR) {
            state.midPrice = state.currentPrice + halfEffectiveADR;
        }

        const lowPrice = state.midPrice - (effectiveADRInPrice / 2);
        let percentage = (state.currentPrice - lowPrice) / effectiveADRInPrice;
        percentage = Math.max(0, Math.min(1, percentage));

        // Calculate central meter's top offset within the visualizationsContentWrapper
        const centralMeterTopOffset = (visualizationsContentWrapper?.offsetHeight / 2) - (dayRangeMeter?.offsetHeight / 2);
        // Calculate float's top position relative to the central meter's top
        const floatTop = `${centralMeterTopOffset + (1 - percentage) * (dayRangeMeter?.offsetHeight || 0) - (priceFloat?.offsetHeight / 2 || 0)}px`;
        
        if (priceFloat) priceFloat.style.top = floatTop;
        // Price display's top is set here, but its left is handled by updatePriceDisplayStyles
        if (priceDisplay && vizContainer && priceFloat) priceDisplay.style.top = `${vizContainer.offsetTop + parseFloat(floatTop)}px`; // Adjust for vizContainer's absolute position
        
        // NEW: Price formatting (big figure, pip) with dynamic font sizes
        const priceString = state.currentPrice.toFixed(5); // e.g., "1.25500"
        let formattedPrice = '';

        // For major pairs like EUR/USD, GBP/USD, AUD/USD, NZD/USD, the pip is the 4th decimal place.
        // For JPY pairs, the pip is the 2nd decimal place. This simulation assumes 5 decimal places.
        const decimalIndex = priceString.indexOf('.');
        if (decimalIndex !== -1 && priceString.length >= decimalIndex + 5) { // Ensure there are enough decimal places
            const bigFigure = priceString.substring(0, decimalIndex + 3); // e.g., "1.25"
            const pip = priceString.substring(decimalIndex + 3, decimalIndex + 5); // e.g., "50"
            const pipette = priceString.substring(decimalIndex + 5); // Re-enabled

            formattedPrice = `
                <span class="big-figure">${bigFigure}</span><span class="pip">${pip}${config.showPipetteDigit ? `<span class="pipette-inner">${pipette}</span>` : ''}</span>
            `;
        } else {
            formattedPrice = priceString; // Fallback if format is unexpected
        }
        if (priceDisplay) priceDisplay.innerHTML = formattedPrice;
        
        updatePriceDisplayStyles(); // Re-apply styles including horizontal offset and CSS variables

        // Position priceFloat relative to the central meter's horizontal center within its parent (visualizationsContentWrapper)
        // And apply new width and X-offset
        const centralMeterCenterInWrapper = config.centralAxisXPosition + (config.centralMeterFixedThickness / 2);
        if (priceFloat) {
            priceFloat.style.width = `${config.priceFloatWidth}px`; // Apply configurable width
            priceFloat.style.left = `${centralMeterCenterInWrapper}px`; // Position based on center of wrapper
            priceFloat.style.transform = `translateX(${-config.priceFloatWidth / 2 + config.priceFloatXOffset}px) translateY(-50%)`; // Center it then apply X-offset and vertical centering

            // Persistent color based on tick direction for price float
            const priceColor = tick.direction > 0 ? '#22c55e' : (tick.direction < 0 ? '#ef4444' : '#a78bfa'); // Green for up, Red for down, Purple for no change
            priceFloat.style.backgroundColor = priceColor;
            // Enhanced shadow for better glanceability
            priceFloat.style.boxShadow = `0 0 10px ${priceColor}, 0 0 15px ${priceColor} inset`; // Adjusted shadow for thinner line for better glanceability
        }
        // PriceDisplay text color remains static as per previous request.
        // TODO: In the future, the height/thickness of priceFloat could be dynamically
        // determined by the bid-ask spread to visually represent market liquidity/precision.
    }

    /**
     * Checks if the current price is close to the ADR boundary lines and adds a pulse class.
     * (Linked to: "Adaptive Dynamic Cues to Counteract Habituation", "Prioritize Preattentive Pues")
     */
    function checkADRProximity() {
        const centralMeterTopOffset = (visualizationsContentWrapper?.offsetHeight / 2) - (dayRangeMeter?.offsetHeight / 2);
        const topADRY = centralMeterTopOffset;
        const bottomADRY = centralMeterTopOffset + (dayRangeMeter?.offsetHeight || 0);
        const priceFloatY = priceFloat?.offsetTop || 0; // Y position of the price float

        // Convert percentage threshold to pixels relative to meter height
        const proximityThresholdPx = config.meterHeight * (config.adrProximityThreshold / 100);

        adrBoundaryLines.forEach((line, index) => {
            const lineY = parseFloat(line.style.top);
            // Check if price is within proximity threshold of this line
            if (Math.abs(priceFloatY - lineY) < proximityThresholdPx) {
                line.classList.add('pulse');
            } else {
                line.classList.remove('pulse');
            }
        });
    }

    /**
     * Animates the tick pulse effect.
     * Now includes opacity modulation in addition to width, to provide more varied dynamic cues.
     * (Linked to: "Adaptive Dynamic Cues to Counteract Habituation", "Motion/Animation")
     */
    function updateTickPulse(tick) {
        // This function is removed as 'Tick Pulse' is not on the kept list.
        // It's left here as a placeholder comment for clarity in the diff.
    }

    /**
     * Creates a small dot representing a tick's distribution at its price level.
     */
    function createDistributionDot(tick) {
        // This function is removed as 'Distribution Dots' is not on the kept list.
        // It's left here as a placeholder comment for clarity in the diff.
    }

    /**
     * Updates the maximum deflection (highest/lowest price reached by a significant tick).
     */
    function updateMaxDeflection(tick) {
        const now = performance.now();
        if (now - state.maxDeflection.lastUpdateTime > config.maxMarkerDecay) {
            state.maxDeflection.up = 0;
            state.maxDeflection.down = 0;
        }
        let updated = false;
        if (tick.direction > 0 && tick.magnitude > state.maxDeflection.up) { state.maxDeflection.up = tick.magnitude; updated = true; }
        if (tick.direction < 0 && tick.magnitude > state.maxDeflection.down) { state.maxDeflection.down = tick.magnitude; updated = true; }
        if (updated) state.maxDeflection.lastUpdateTime = now;
    }

    /**
     * Renders the max deflection marker, showing its position and fading it out over time.
     */
    function renderMaxDeflection() {
        if (!config.showMaxMarker || !maxDeflectionMarker || !priceFloat) return; // Add null checks for elements

        const now = performance.now();
        const timeSinceUpdate = now - state.maxDeflection.lastUpdateTime;
        const decayProgress = Math.min(timeSinceUpdate / config.maxMarkerDecay, 1);
        
        if (decayProgress >= 1) {
            if (maxDeflectionMarker.style.opacity !== '0') maxDeflectionMarker.style.opacity = '0';
            return;
        }
        
        const upPosition = state.maxDeflection.up * config.pulseScale;
        const downPosition = state.maxDeflection.down * config.pulseScale;
        
        const centralMeterLeftEdge = config.centralAxisXPosition;
        maxDeflectionMarker.style.top = priceFloat.style.top; // Match vertical position of priceFloat

        if (upPosition > downPosition) {
            maxDeflectionMarker.style.left = `${centralMeterLeftEdge + config.centralMeterFixedThickness}px`;
            maxDeflectionMarker.style.transform = `translateX(0px) translateY(-50%)`; // Reset transform for horizontal movement
            maxDeflectionMarker.style.backgroundColor = '#60a5fa';
        } else {
            maxDeflectionMarker.style.left = `${centralMeterLeftEdge}px`;
            maxDeflectionMarker.style.transform = `translateX(${-downPosition}px) translateY(-50%)`;
            maxDeflectionMarker.style.backgroundColor = '#f87171';
        }
        maxDeflectionMarker.style.opacity = `${0.7 * (1 - decayProgress)}`;
    }
    
    // --- IDEATION CONCEPT IMPLEMENTATIONS ---
    /**
     * Updates the calculated volatility based on recent tick magnitudes and frequency.
     */
    function updateVolatility() {
        if (!config.showVolatilityOrb) return;
        const lookback = 5000;
        const now = performance.now();
        state.ticks = state.ticks.filter(t => now - t.time < lookback);
        if (state.ticks.length < 5) { state.volatility *= 0.99; return; }
        
        const magnitudes = state.ticks.map(t => t.magnitude);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const frequency = state.ticks.length / (lookback / 1000);
        
        const volScore = (avgMagnitude * 0.5) + (frequency * 0.5);
        state.volatility = state.volatility * 0.95 + volScore * 0.05;
    }

    /**
     * Renders the volatility orb, scaling its size, opacity, color, and animation speed based on calculated volatility.
     * (Linked to: "Adaptive Dynamic Cues to Counteract Habituation", "Visualizing Market Volatility and 'Heartbeat'")
     * @param {string|null} flashColor - Optional: 'R,G,B' string for flash color.
     * @param {number|null} flashOpacity - Optional: Opacity for the flash.
     */
    function renderVolatilityOrb(flashColor = null, flashOpacity = null) {
        if (!volatilityOrb) return; // Add null check for volatilityOrb

        // If the orb is currently flashing and this call is not explicitly for a flash, return
        if (state.isOrbFlashing && flashColor === null) {
            return;
        }

        if (!config.showVolatilityOrb) return;
        
        const baseSize = config.volatilityOrbBaseWidth;
        const size = Math.min(baseSize, config.visualizationsContentWidth); // Ensure it doesn't exceed total width

        volatilityOrb.style.width = `${size}px`;
        volatilityOrb.style.height = `${size}px`;
        // volatilityOrb.style.opacity is handled by the gradient itself or element opacity below

        let currentOrbColorR, currentOrbColorG, currentOrbColorB;
        let currentOrbBaseOpacity; // This will be the base opacity for the gradient stops

        // Calculate the normal orb's color and base opacity first
        const volatilityIntensity = config.volatilityOrbInvertBrightness ? Math.min(state.volatility, 4) : Math.min(state.volatility, 2);

        switch (config.volatilityColorMode) {
            case 'directional':
                currentOrbColorR = 150; currentOrbColorG = 150; currentOrbColorB = 150; // Greyish neutral
                if (state.lastTickDirection > 0) { currentOrbColorR = 96; currentOrbColorG = 165; currentOrbColorB = 250; } // Blue for up
                else if (state.lastTickDirection < 0) { currentOrbColorR = 239; currentOrbColorG = 68; currentOrbColorB = 68; } // Red for down
                break;
            case 'intensity':
                currentOrbColorR = Math.round(75 + (147 - 75) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorG = Math.round(85 + (197 - 85) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorB = Math.round(99 + (253 - 99) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                break;
            case 'singleHue': // Purple Spectrum
                currentOrbColorR = Math.round(167 - (167 - 109) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorG = Math.round(139 - (139 - 40) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorB = Math.round(250 - (250 - 217) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                break;
            default: // Fallback to intensity
                currentOrbColorR = Math.round(75 + (147 - 75) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorG = Math.round(85 + (197 - 85) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                currentOrbColorB = Math.round(99 + (253 - 99) * (volatilityIntensity / (config.volatilityOrbInvertBrightness ? 4 : 2)));
                break;
        }

        if (config.volatilityOrbInvertBrightness) {
            currentOrbBaseOpacity = Math.min(1.0, 0.2 + (volatilityIntensity * 0.2));
        } else {
            currentOrbBaseOpacity = (0.5 + volatilityIntensity * 0.25);
        }

        let finalColorString = `${currentOrbColorR}, ${currentOrbColorG}, ${currentOrbColorB}`;
        let finalOpacityForGradient = flashOpacity !== null ? flashOpacity : currentOrbBaseOpacity; // Use flashOpacity if provided, else currentOrbBaseOpacity

        let scale = 1; // Default scale for outward growth

        // Apply flash overrides if flashing
        if (flashColor) {
            finalColorString = flashColor; // Use the flash color directly
            // Ensure flash opacity is at least the current orb's base opacity, or the configured flash intensity, whichever is higher
            finalOpacityForGradient = Math.max(currentOrbBaseOpacity, flashOpacity); 
            scale = config.volatilityOrbInvertBrightness ? 1 : (1 + Math.min(state.volatility * 0.5, 2)); // Keep scale same during flash for outward
            volatilityOrb.style.opacity = 1; // Ensure element is fully visible during flash
        } else {
            // If not flashing, apply normal scale and element opacity for outward growth
            if (!config.volatilityOrbInvertBrightness) {
                scale = 1 + Math.min(state.volatility * 0.5, 2);
                volatilityOrb.style.opacity = 0.5 + Math.min(state.volatility * 0.2, 0.5);
            } else {
                volatilityOrb.style.opacity = 1; // Inward growth always full element opacity
            }
        }

        if (config.volatilityOrbInvertBrightness) {
            // When flashing, ensure the inner transparent stop still has some opacity
            const innerTransparentStop = flashColor ? 5 : Math.max(5, 80 - (volatilityIntensity * 18.75)); // Keep inner stop fixed at 5% when flashing
            
            // Ensure the center of the gradient has a minimum opacity during flash
            const centerFlashOpacity = flashColor ? Math.max(0.05, finalOpacityForGradient * 0.1) : 0; // If flashing, ensure at least 0.05 opacity at center
            
            volatilityOrb.style.background = `radial-gradient(circle, rgba(${finalColorString}, ${centerFlashOpacity}) ${innerTransparentStop}%, rgba(${finalColorString}, ${finalOpacityForGradient}) 100%)`; 
            volatilityOrb.style.transform = `translate(-50%, -50%)`;
        } else {
            // For outward growth, adjust all stops based on finalOpacityForGradient
            const centerOpacity = finalOpacityForGradient * 0.1;
            const midOpacity1 = finalOpacityForGradient * 0.3;
            const midOpacity2 = finalOpacityForGradient * 0.6;
            const outerOpacity = finalOpacityForGradient;

            volatilityOrb.style.background = `radial-gradient(circle, rgba(${finalColorString}, ${centerOpacity}) 0%, rgba(${finalColorString}, ${midOpacity1}) 40%, rgba(${finalColorString}, ${midOpacity2}) 60%, rgba(${finalColorString}, ${outerOpacity}) 80%, rgba(${finalColorString}, 0) 100%)`;
            volatilityOrb.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        // Always set the transition property based on whether it's flashing or not
        if (state.isOrbFlashing) {
            volatilityOrb.style.transition = 'background 0.1s ease-out, opacity 0.1s ease-out, transform 0.1s ease-out';
        } else {
            volatilityOrb.style.transition = `transform ${Math.max(0.5, 1.5 - (state.volatility * 0.5))}s ease-in-out, opacity ${Math.max(0.5, 1.5 - (state.volatility * 0.5))}s ease-in-out, background ${Math.max(0.5, 1.5 - (state.volatility * 0.5))}s ease-in-out`;
        }
    }

    /**
     * Updates the buy/sell pressure accumulation based on tick direction and magnitude.
     */
    function updatePressure(tick) {
        // This function is removed as 'Pressure Arcs' is not on the kept list.
        // It's left here as a placeholder comment for clarity in the diff.
    }
    
    /**
     * Renders the pressure arcs, scaling their border width and opacity based on pressure values.
     */
    function renderPressureArcs() {
        // This function is removed as 'Pressure Arcs' is not on the kept list.
        // It's left here as a placeholder comment for clarity in the diff.
    }

    /**
     * Creates a visual ripple effect for significant events (large ticks).
     */
    function createEventRipple(tick) {
        // This function is removed as 'Event Ripples' is not on the kept list.
        // It's left here as a placeholder comment for clarity in the diff.
    }
    
    /**
     * Briefly flashes the meter background based on tick direction.
     */
    function flashMeter(direction) {
        if (!vizContainer) return; // Add null check for vizContainer

        const flashDiv = document.createElement('div');
        // Use config.flashIntensity for opacity
        flashDiv.style.cssText = `position:absolute; top:0; left:0; width:100%; height:100%; z-index:100; opacity:${config.flashIntensity}; transition:opacity 0.3s ease-out; pointer-events:none;`;
        flashDiv.style.background = direction > 0 ? 'radial-gradient(circle, rgba(96,165,250,0.6) 0%, transparent 70%)' : 'radial-gradient(circle, rgba(248,113,113,0.6) 0%, transparent 70%)';
        vizContainer.appendChild(flashDiv);
        setTimeout(() => { flashDiv.style.opacity = '0'; setTimeout(() => flashDiv.remove(), 300); }, 50);
    }

    /**
     * Briefly flashes the volatility orb with a directional color and intensity.
     * @param {number} direction - The direction of the tick (1 for up, -1 for down).
     */
    function flashVolatilityOrb(direction) {
        if (!config.showOrbFlash || !volatilityOrb) return; // Add null check for volatilityOrb

        state.isOrbFlashing = true; // Set the flashing state

        const flashColor = direction > 0 ? '96,165,250' : '248,113,113'; // Blue for up, Red for down
        const flashOpacity = config.orbFlashIntensity;

        // Call renderVolatilityOrb with flash parameters
        renderVolatilityOrb(flashColor, flashOpacity);

        // Revert to normal orb rendering after a short delay
        setTimeout(() => {
            state.isOrbFlashing = false; // Reset the flashing state
            renderVolatilityOrb(); // This will re-apply the normal volatility-based style
        }, 150); // Short flash duration
    }

    /**
     * Converts a price value to a Y-coordinate (pixels) within the meter's height.
     * @param {number} price - The price value to convert.
     * @returns {number} The corresponding Y-coordinate in pixels relative to meter's top.
     */
    function priceToY(price) {
        const effectiveADRInPrice = Math.max(config.adrRange / 10000, state.maxObservedPrice - state.minObservedPrice);
        const lowPrice = state.midPrice - (effectiveADRInPrice / 2);
        let percentage = (price - lowPrice) / effectiveADRInPrice;
        percentage = Math.max(0, Math.min(1, percentage));
        return (1 - percentage) * (dayRangeMeter?.offsetHeight || 0); // Invert Y-axis for display (0 is top of meter)
    }

    /**
     * Renders the Asymmetrical Market Profile based on accumulated tick data.
     * (Linked to: "Minimize Extraneous Cognitive Load", "Need-to-Know Information Display Philosophy" via depth mode)
     */
    function renderMarketProfile() {
        if (!config.showMarketProfile || !marketProfileContainer || !visualizationsContentWrapper || !dayRangeMeter) { // Add null checks
            if (marketProfileContainer) marketProfileContainer.innerHTML = '';
            return;
        }

        marketProfileContainer.innerHTML = '';

        let relevantTicks;
        if (config.distributionDepthMode === 'all') {
            relevantTicks = state.allTicks;
        } else {
            const numTicks = Math.floor(state.allTicks.length * (config.distributionPercentage / 100));
            relevantTicks = state.allTicks.slice(Math.max(0, state.allTicks.length - numTicks));
        }

        let profileData = new Map(); // Will store { buy: count, sell: count } or { total: count }

        relevantTicks.forEach(tick => {
            const priceBucket = Math.floor(tick.price * (10000 / config.priceBucketSize));
            if (!profileData.has(priceBucket)) {
                profileData.set(priceBucket, { buy: 0, sell: 0, total: 0 });
            }
            const bucket = profileData.get(priceBucket);
            if (tick.direction > 0) {
                bucket.buy += 1;
            } else {
                bucket.sell += 1;
            }
            bucket.total += 1; // Always increment total for single-sided view
        });

        let maxDeviation = 0;
        profileData.forEach(data => {
            if (config.showSingleSidedProfile) {
                maxDeviation = Math.max(maxDeviation, data.total);
            } else {
                maxDeviation = Math.max(maxDeviation, data.buy, data.sell);
            }
        });

        const centralMeterLeftEdge = config.centralAxisXPosition;
        const centralMeterRightEdge = centralMeterLeftEdge + config.centralMeterFixedThickness;
        const centralMeterTopOffsetInWrapper = (visualizationsContentWrapper.offsetHeight / 2) - (dayRangeMeter.offsetHeight / 2);
        
        // Use actual available width for scaling
        const availableWidthLeft = centralMeterLeftEdge;
        const availableWidthRight = visualizationsContentWrapper.offsetWidth - centralMeterRightEdge;

        const scaleFactor = maxDeviation > 0 ? (
            config.showSingleSidedProfile ?
                (config.singleSidedProfileSide === 'left' ? availableWidthLeft : availableWidthRight) / maxDeviation :
                Math.min(availableWidthLeft, availableWidthRight) / maxDeviation
        ) : 0;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', `0 0 ${visualizationsContentWrapper.offsetWidth} ${visualizationsContentWrapper.offsetHeight}`);
        
        const sortedBuckets = Array.from(profileData.keys()).sort((a, b) => a - b);
        
        const profilePoints = sortedBuckets.map(priceBucket => {
            const data = profileData.get(priceBucket);
            const price = priceBucket * (config.priceBucketSize / 10000);
            const y = priceToY(price);
            const barHeight = config.priceBucketSize / (config.adrRange / (dayRangeMeter?.offsetHeight || 1)); // Add null check for dayRangeMeter.offsetHeight
            return {
                y: centralMeterTopOffsetInWrapper + y + barHeight / 2, // Y-position relative to visualizationsContentWrapper's top, centered
                buyWidth: data.buy * scaleFactor,
                sellWidth: data.sell * scaleFactor,
                totalWidth: data.total * scaleFactor,
                barHeight: barHeight // Include barHeight for easier calculation in loops
            };
        });

        if (config.marketProfileView === 'bars') {
            profilePoints.forEach(p => {
                // Render single-sided bars
                if (config.showSingleSidedProfile) {
                    const bar = document.createElement('div');
                    bar.className = 'mp-bar-buy'; // Use a consistent color for combined profile
                    bar.style.top = `${p.y - p.barHeight / 2}px`; // Vertically center the bar
                    bar.style.height = `${p.barHeight}px`;
                    bar.style.width = `${p.totalWidth}px`;
                    if (config.singleSidedProfileSide === 'left') {
                        bar.style.left = `${centralMeterLeftEdge - p.totalWidth}px`;
                        bar.style.backgroundColor = 'rgba(191, 147, 255, 0.7)'; // Brighter purple
                    } else { // right
                        bar.style.left = `${centralMeterRightEdge}px`;
                        bar.style.backgroundColor = 'rgba(191, 147, 255, 0.7)'; // Brighter purple
                    }
                    marketProfileContainer.appendChild(bar);
                } else {
                    // Existing dual-sided bars
                    if (p.buyWidth > 0) {
                        const buyBar = document.createElement('div');
                        buyBar.className = 'mp-bar-buy';
                        buyBar.style.top = `${p.y - p.barHeight / 2}px`; // Vertically center the bar
                        buyBar.style.height = `${p.barHeight}px`;
                        buyBar.style.width = `${p.buyWidth}px`;
                        buyBar.style.left = `${centralMeterRightEdge}px`;
                        marketProfileContainer.appendChild(buyBar);
                    }
                    if (p.sellWidth > 0) {
                        const sellBar = document.createElement('div');
                        sellBar.className = 'mp-bar-sell';
                        sellBar.style.top = `${p.y - p.barHeight / 2}px`; // Vertically center the bar
                        sellBar.style.height = `${p.barHeight}px`;
                        sellBar.style.width = `${p.sellWidth}px`;
                        sellBar.style.left = `${centralMeterLeftEdge - p.sellWidth}px`;
                        marketProfileContainer.appendChild(sellBar);
                    }
                }
            });
        } else { // 'outline' view
            if (config.showSingleSidedProfile) {
                const singleArea = d3.area()
                    .x0(d => config.singleSidedProfileSide === 'left' ? centralMeterLeftEdge - d.totalWidth : centralMeterRightEdge)
                    .x1(d => config.singleSidedProfileSide === 'left' ? centralMeterLeftEdge : centralMeterRightEdge + d.totalWidth)
                    .y(d => d.y)
                    .curve(d3.curveBasis);

                if (profilePoints.length > 0) {
                    const singlePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    singlePath.setAttribute('d', singleArea(profilePoints));
                    singlePath.setAttribute('class', 'mp-outline-path');
                    singlePath.style.stroke = '#bf93ff'; // Brighter purple outline
                    singlePath.style.fill = 'rgba(191, 147, 255, 0.7)'; // Brighter purple fill
                    svg.appendChild(singlePath);
                }
            } else {
                // Existing dual-sided outlines
                const buyArea = d3.area()
                    .x0(centralMeterRightEdge)
                    .x1(d => centralMeterRightEdge + d.buyWidth)
                    .y(d => d.y)
                    .curve(d3.curveBasis);

                const sellArea = d3.area()
                    .x0(d => centralMeterLeftEdge - d.sellWidth) // Corrected x0/x1 for left-extending area
                    .x1(centralMeterLeftEdge)
                    .y(d => d.y)
                    .curve(d3.curveBasis);

                if (profilePoints.length > 0) {
                    const buyPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    buyPath.setAttribute('d', buyArea(profilePoints));
                    buyPath.setAttribute('class', 'mp-outline-path mp-outline-buy');
                    svg.appendChild(buyPath);

                    const sellPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    sellPath.setAttribute('d', sellArea(profilePoints));
                    sellPath.setAttribute('class', 'mp-outline-path mp-outline-sell');
                    svg.appendChild(sellPath);
                }
            }
            marketProfileContainer.appendChild(svg);
        }
    }

    // --- Helper to update all elements dependent on total display width or central meter height ---
    // This function is crucial for ensuring all visual elements correctly adapt to changes in meter dimensions
    // or when the viz-wrapper is resized by the user.
    function updateAllDependentElements() {
        // Set the width of the visualizations content wrapper
        if (visualizationsContentWrapper) visualizationsContentWrapper.style.width = `${config.visualizationsContentWidth}px`;
        // Set the central meter's height (its width is fixed in CSS)
        if (dayRangeMeter) dayRangeMeter.style.height = `${config.meterHeight}px`;

        setupDayRangeMeter(); // Re-draw ADR meter steps/boundary lines (which depend on central meter size/position)
        // Dummy tick to trigger price float/display update, as its position depends on central meter's top offset
        // Pass a dummy tick with the last known direction to ensure correct color/arrow rendering.
        updateDayRangeMeter({ direction: state.lastTickDirection, magnitude: 0 }); 
        renderMarketProfile(); // Re-render market profile based on new total display width and central meter position
        renderMaxDeflection(); // Re-render max deflection marker (if kept)
        // Removed: updateTickPulse({ direction: state.lastTickDirection, magnitude: 0 });
        // Removed: createDistributionDot is ephemeral, so no need to call it here.
        updatePriceDisplayStyles(); // Ensure price display is correctly positioned
        checkADRProximity(); // Re-check ADR proximity
        renderVolatilityOrb(); // Ensure orb color mode is updated
    }

    // --- MAIN ANIMATION LOOP ---
    /**
     * The main animation loop, called repeatedly using requestAnimationFrame.
     */
    function gameLoop() {
        generateTick();
        // These are called in processTick and updateAllDependentElements, but
        // calling them here ensures they are always rendered even if no tick occurs.
        renderMaxDeflection(); // Render Max Deflection (if kept)
        updateVolatility();
        renderVolatilityOrb(); // This will now conditionally render based on isOrbFlashing
        // Removed: renderPressureArcs();
        renderMarketProfile(); // Ensure market profile updates
        checkADRProximity(); // Continuously check ADR proximity for pulsing effect

        requestAnimationFrame(gameLoop);
    }

    // --- INITIALIZATION ---
    setupControls();
    updatePriceDisplayStyles(); // Apply initial price display styles

    // Initial setup of meter dimensions and elements
    updateAllDependentElements(); // Call this once to set everything up initially

    updateElementVisibility();

    // Setup ResizeObserver to handle viz-wrapper resizing (user dragging the overall display)
    const vizWrapperResizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
            if (entry.target === vizWrapper) {
                // When viz-wrapper resizes, we only need to re-center visualizationsContentWrapper
                // and re-calculate positions of elements that depend on vizContainer's size
                updateAllDependentElements();
            }
        }
    });
    if (vizWrapper) vizWrapperResizeObserver.observe(vizWrapper); // Add null check for vizWrapper

    requestAnimationFrame(gameLoop);
});
</script>

</body>
</html>
