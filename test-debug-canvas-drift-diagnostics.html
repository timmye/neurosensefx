<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drift Diagnostics - NeuroSense FX</title>
    <style>
        body {
            font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: #0f172a;
            color: #e2e8f0;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }

        .test-controls {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }

        .test-controls button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        .test-controls button:hover {
            background: #2563eb;
        }

        .test-controls button:disabled {
            background: #64748b;
            cursor: not-allowed;
        }

        .monitoring-panel {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #334155;
            max-height: 400px;
            overflow-y: auto;
        }

        .test-element {
            position: fixed;
            width: 220px;
            height: 120px;
            background: #111827;
            border: 2px solid #374151;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 14px;
            cursor: move;
            user-select: none;
            z-index: 1000;
        }

        .test-element canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.active {
            background: #10b981;
            box-shadow: 0 0 4px #10b981;
        }

        .status-indicator.inactive {
            background: #ef4444;
            box-shadow: 0 0 4px #ef4444;
        }

        .status-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 4px #f59e0b;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .log-entry.info {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
        }

        .log-entry.warning {
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid #f59e0b;
        }

        .log-entry.error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }

        .drift-detected {
            background: rgba(239, 68, 68, 0.2) !important;
            border-left: 3px solid #ef4444 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: #1e293b;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #334155;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #3b82f6;
        }

        .metric-label {
            font-size: 12px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .zoom-control {
            background: #0f172a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #334155;
            margin-bottom: 10px;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .coordinate-display {
            font-size: 11px;
            color: #64748b;
            margin-top: 10px;
        }

        .test-instructions {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .test-instructions h3 {
            margin-top: 0;
            color: #3b82f6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Canvas Positioning Drift Diagnostics</h1>
            <p>NeuroSense FX - Automated Canvas Drift Detection and Analysis System</p>
            <div>
                <span class="status-indicator" id="monitoring-status"></span>
                <span id="monitoring-status-text">Monitoring Inactive</span>
            </div>
        </div>

        <div class="test-instructions">
            <h3>üìã Test Instructions</h3>
            <ol>
                <li><strong>Start Monitoring:</strong> Click "Start Monitoring" to activate drift detection</li>
                <li><strong>Create Test Elements:</strong> Add canvas elements to test different scenarios</li>
                <li><strong>Interact with Elements:</strong> Drag, resize, and zoom to trigger potential drift</li>
                <li><strong>Monitor Logs:</strong> Watch for drift events and positioning anomalies</li>
                <li><strong>Browser Zoom:</strong> Use browser zoom (Ctrl +/-) to test DPR changes</li>
                <li><strong>Analyze Results:</strong> Review drift detection reports and patterns</li>
            </ol>
        </div>

        <div class="test-controls">
            <h3>üéÆ Test Controls</h3>
            <div class="controls-grid">
                <button id="start-monitoring">Start Monitoring</button>
                <button id="stop-monitoring" disabled>Stop Monitoring</button>
                <button id="create-test-element">Create Test Element</button>
                <button id="clear-test-elements">Clear Test Elements</button>
                <button id="run-automated-tests">Run Automated Tests</button>
                <button id="generate-report">Generate Report</button>
                <button id="clear-logs">Clear Logs</button>
            </div>

            <div class="zoom-control">
                <strong>Zoom Simulation:</strong>
                <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1">
                <div>Current Zoom: <span id="zoom-value">1.0</span>x</div>
            </div>

            <div class="zoom-control">
                <strong>Resize Simulation:</strong>
                <input type="range" id="resize-slider" min="100" max="500" step="10" value="220">
                <div>Element Width: <span id="resize-value">220</span>px</div>
            </div>
        </div>

        <div class="test-grid">
            <div class="metric-card">
                <div class="metric-label">Elements Monitored</div>
                <div class="metric-value" id="elements-count">0</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Drift Events Detected</div>
                <div class="metric-value" id="drift-count">0</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">High Severity Drift</div>
                <div class="metric-value" id="high-severity-count">0</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Monitoring Duration</div>
                <div class="metric-value" id="monitoring-duration">0s</div>
            </div>
        </div>

        <div class="monitoring-panel">
            <h3>üìä Drift Detection Logs</h3>
            <div id="log-container"></div>
        </div>
    </div>

    <script type="module">
        // Import drift monitor (would work in real Svelte environment)
        // import { canvasDriftMonitor } from './src/lib/diagnostics/canvasDriftMonitor.js';

        // Mock implementation for testing
        class MockCanvasDriftMonitor {
            constructor() {
                this.isMonitoring = false;
                this.elementMonitors = new Map();
                this.driftEvents = [];
                this.startTime = null;
            }

            startMonitoring() {
                this.isMonitoring = true;
                this.startTime = performance.now();
                this.log('info', 'Monitoring started');
                this.startMonitoringLoop();
            }

            stopMonitoring() {
                this.isMonitoring = false;
                this.log('info', 'Monitoring stopped');
            }

            registerElement(id, element, type) {
                this.elementMonitors.set(id, {
                    id,
                    element,
                    type,
                    registeredAt: performance.now(),
                    lastSnapshot: null
                });
                this.log('info', `Registered ${type} element: ${id}`);
                return true;
            }

            unregisterElement(id) {
                if (this.elementMonitors.has(id)) {
                    this.elementMonitors.delete(id);
                    this.log('info', `Unregistered element: ${id}`);
                }
            }

            takeSnapshot(elementId, eventType, metadata = {}) {
                if (!this.isMonitoring) return null;

                const monitor = this.elementMonitors.get(elementId);
                if (!monitor) return null;

                const timestamp = performance.now();
                const snapshot = {
                    timestamp,
                    eventType,
                    elementId,
                    type: monitor.type,
                    elementRect: monitor.element.getBoundingClientRect(),
                    metadata
                };

                // Simulate drift detection
                if (monitor.lastSnapshot) {
                    const drift = this.simulateDriftDetection(monitor.lastSnapshot, snapshot);
                    if (drift.detected) {
                        this.recordDriftEvent(elementId, drift);
                    }
                }

                monitor.lastSnapshot = snapshot;
                return snapshot;
            }

            simulateDriftDetection(previous, current) {
                const positionDelta = {
                    leftDelta: current.elementRect.left - previous.elementRect.left,
                    topDelta: current.elementRect.top - previous.elementRect.top,
                    widthDelta: current.elementRect.width - previous.elementRect.width,
                    heightDelta: current.elementRect.height - previous.elementRect.height
                };

                const detected = Math.abs(positionDelta.leftDelta) > 0.1 ||
                               Math.abs(positionDelta.topDelta) > 0.1 ||
                               Math.abs(positionDelta.widthDelta) > 0.1 ||
                               Math.abs(positionDelta.heightDelta) > 0.1;

                if (detected) {
                    return {
                        detected: true,
                        timestamp: current.timestamp,
                        positionDelta,
                        severity: this.calculateSeverity(positionDelta)
                    };
                }

                return { detected: false };
            }

            calculateSeverity(delta) {
                const score = Math.abs(delta.leftDelta) + Math.abs(delta.topDelta) +
                             Math.abs(delta.widthDelta) + Math.abs(delta.heightDelta);

                if (score > 5) return 'high';
                if (score > 2) return 'medium';
                return 'low';
            }

            recordDriftEvent(elementId, drift) {
                const event = {
                    elementId,
                    timestamp: drift.timestamp,
                    severity: drift.severity,
                    analysis: drift
                };

                this.driftEvents.push(event);
                this.log('warning', `DRIFT DETECTED [${drift.severity.toUpperCase()}]`, event);
                updateMetrics();
            }

            startMonitoringLoop() {
                if (!this.isMonitoring) return;

                // Take snapshots for all monitored elements
                this.elementMonitors.forEach((monitor, id) => {
                    this.takeSnapshot(id, 'monitoring_loop');
                });

                // Schedule next loop
                setTimeout(() => this.startMonitoringLoop(), 100);
            }

            log(type, message, data = null) {
                const logContainer = document.getElementById('log-container');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;

                const timestamp = new Date().toLocaleTimeString();
                const content = `[${timestamp}] ${message}`;

                logEntry.innerHTML = `
                    <div>${content}</div>
                    ${data ? `<div class="coordinate-display">${JSON.stringify(data, null, 2)}</div>` : ''}
                `;

                if (type === 'warning' && message.includes('DRIFT')) {
                    logEntry.classList.add('drift-detected');
                }

                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            generateReport() {
                const report = {
                    generatedAt: new Date().toISOString(),
                    elementsMonitored: this.elementMonitors.size,
                    totalDriftEvents: this.driftEvents.length,
                    bySeverity: this.driftEvents.reduce((acc, event) => {
                        acc[event.severity] = (acc[event.severity] || 0) + 1;
                        return acc;
                    }, {}),
                    monitoringDuration: this.startTime ? performance.now() - this.startTime : 0
                };

                this.log('info', 'DIAGNOSTIC REPORT:', report);
                return report;
            }
        }

        // Create global instance
        const canvasDriftMonitor = new MockCanvasDriftMonitor();

        // Test element management
        let testElementCount = 0;
        const testElements = new Map();

        // DOM elements
        const startBtn = document.getElementById('start-monitoring');
        const stopBtn = document.getElementById('stop-monitoring');
        const createTestBtn = document.getElementById('create-test-element');
        const clearTestBtn = document.getElementById('clear-test-elements');
        const runTestsBtn = document.getElementById('run-automated-tests');
        const generateReportBtn = document.getElementById('generate-report');
        const clearLogsBtn = document.getElementById('clear-logs');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const resizeSlider = document.getElementById('resize-slider');
        const resizeValue = document.getElementById('resize-value');

        // Update functions
        function updateStatus(isActive) {
            const statusIndicator = document.getElementById('monitoring-status');
            const statusText = document.getElementById('monitoring-status-text');

            if (isActive) {
                statusIndicator.className = 'status-indicator active';
                statusText.textContent = 'Monitoring Active';
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } else {
                statusIndicator.className = 'status-indicator inactive';
                statusText.textContent = 'Monitoring Inactive';
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        function updateMetrics() {
            document.getElementById('elements-count').textContent = canvasDriftMonitor.elementMonitors.size;
            document.getElementById('drift-count').textContent = canvasDriftMonitor.driftEvents.length;
            document.getElementById('high-severity-count').textContent =
                canvasDriftMonitor.driftEvents.filter(e => e.severity === 'high').length;
        }

        function updateMonitoringDuration() {
            if (canvasDriftMonitor.startTime && canvasDriftMonitor.isMonitoring) {
                const duration = Math.floor((performance.now() - canvasDriftMonitor.startTime) / 1000);
                document.getElementById('monitoring-duration').textContent = `${duration}s`;
            }
        }

        // Event handlers
        startBtn.addEventListener('click', () => {
            canvasDriftMonitor.startMonitoring();
            updateStatus(true);
            startDurationTimer();
        });

        stopBtn.addEventListener('click', () => {
            canvasDriftMonitor.stopMonitoring();
            updateStatus(false);
        });

        createTestBtn.addEventListener('click', () => {
            createTestElement();
        });

        clearTestBtn.addEventListener('click', () => {
            clearTestElements();
        });

        runTestsBtn.addEventListener('click', () => {
            runAutomatedTests();
        });

        generateReportBtn.addEventListener('click', () => {
            canvasDriftMonitor.generateReport();
        });

        clearLogsBtn.addEventListener('click', () => {
            document.getElementById('log-container').innerHTML = '';
        });

        zoomSlider.addEventListener('input', (e) => {
            const zoom = parseFloat(e.target.value);
            zoomValue.textContent = zoom.toFixed(1);
            applyZoomToElements(zoom);
        });

        resizeSlider.addEventListener('input', (e) => {
            const width = parseInt(e.target.value);
            resizeValue.textContent = width;
            resizeTestElements(width);
        });

        // Test element functions
        function createTestElement() {
            testElementCount++;
            const elementId = `test-element-${testElementCount}`;

            const element = document.createElement('div');
            element.className = 'test-element';
            element.id = elementId;
            element.style.left = `${100 + (testElementCount * 30)}px`;
            element.style.top = `${100 + (testElementCount * 30)}px`;
            element.innerHTML = `
                <canvas id="${elementId}-canvas"></canvas>
            `;

            document.body.appendChild(element);

            // Create canvas context
            const canvas = element.querySelector('canvas');
            canvas.width = 220;
            canvas.height = 120;
            const ctx = canvas.getContext('2d');

            // Draw test pattern
            drawTestPattern(ctx, canvas.width, canvas.height, testElementCount);

            // Make element draggable
            makeDraggable(element);

            // Register with monitor
            canvasDriftMonitor.registerElement(elementId, element, 'test');

            testElements.set(elementId, { element, canvas, ctx });
            updateMetrics();

            canvasDriftMonitor.log('info', `Created test element: ${elementId}`);
        }

        function clearTestElements() {
            testElements.forEach(({ element }) => {
                element.remove();
            });
            testElements.clear();
            testElementCount = 0;
            updateMetrics();
            canvasDriftMonitor.log('info', 'Cleared all test elements');
        }

        function drawTestPattern(ctx, width, height, seed) {
            // Clear canvas
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;

            for (let x = 0; x <= width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let y = 0; y <= height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw test elements
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(10, 10, 30, 30);

            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(width - 25, 25, 15, 0, Math.PI * 2);
            ctx.fill();

            // Draw text
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px monospace';
            ctx.fillText(`Element ${seed}`, 10, height - 10);

            // Draw crosshair for position reference
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 2 - 10, height / 2);
            ctx.lineTo(width / 2 + 10, height / 2);
            ctx.moveTo(width / 2, height / 2 - 10);
            ctx.lineTo(width / 2, height / 2 + 10);
            ctx.stroke();
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            element.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = element.offsetLeft;
                initialY = element.offsetTop;
                element.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                element.style.left = `${initialX + dx}px`;
                element.style.top = `${initialY + dy}px`;

                // Monitor drag movement
                canvasDriftMonitor.takeSnapshot(element.id, 'drag_move', {
                    deltaX: dx,
                    deltaY: dy,
                    cause: 'user_drag'
                });
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'move';

                    canvasDriftMonitor.takeSnapshot(element.id, 'drag_end', {
                        cause: 'user_drag_end'
                    });
                }
            });
        }

        function applyZoomToElements(zoom) {
            testElements.forEach(({ element, canvas, ctx }, id) => {
                const baseSize = parseInt(resizeSlider.value);
                const newWidth = baseSize * zoom;
                const newHeight = 120 * zoom;

                element.style.width = `${newWidth}px`;
                element.style.height = `${newHeight}px`;

                // Redraw canvas with new size
                canvas.width = newWidth;
                canvas.height = newHeight;
                drawTestPattern(ctx, newWidth, newHeight, parseInt(id.split('-')[2]));

                canvasDriftMonitor.takeSnapshot(id, 'zoom_change', {
                    zoomLevel: zoom,
                    newWidth,
                    newHeight,
                    cause: 'zoom_simulation'
                });
            });
        }

        function resizeTestElements(width) {
            testElements.forEach(({ element, canvas, ctx }, id) => {
                const zoom = parseFloat(zoomSlider.value);
                const newWidth = width * zoom;
                const newHeight = 120 * zoom;

                element.style.width = `${newWidth}px`;

                // Redraw canvas
                canvas.width = newWidth;
                canvas.height = newHeight;
                drawTestPattern(ctx, newWidth, newHeight, parseInt(id.split('-')[2]));

                canvasDriftMonitor.takeSnapshot(id, 'resize_change', {
                    newWidth,
                    newHeight,
                    cause: 'resize_simulation'
                });
            });
        }

        function runAutomatedTests() {
            canvasDriftMonitor.log('info', 'Starting automated test sequence...');

            // Create test element for automated testing
            createTestElement();

            setTimeout(() => {
                // Test 1: Rapid resize
                canvasDriftMonitor.log('info', 'Test 1: Rapid resize sequence');
                const resizeSequence = [150, 300, 200, 400, 220];
                resizeSequence.forEach((width, index) => {
                    setTimeout(() => {
                        resizeSlider.value = width;
                        resizeValue.textContent = width;
                        resizeTestElements(width);
                    }, index * 200);
                });
            }, 1000);

            setTimeout(() => {
                // Test 2: Zoom simulation
                canvasDriftMonitor.log('info', 'Test 2: Zoom simulation');
                const zoomSequence = [1.5, 0.8, 2.0, 1.0];
                zoomSequence.forEach((zoom, index) => {
                    setTimeout(() => {
                        zoomSlider.value = zoom;
                        zoomValue.textContent = zoom.toFixed(1);
                        applyZoomToElements(zoom);
                    }, index * 500);
                });
            }, 3000);

            setTimeout(() => {
                canvasDriftMonitor.log('info', 'Automated tests completed');
                generateReportBtn.click();
            }, 6000);
        }

        function startDurationTimer() {
            setInterval(() => {
                updateMonitoringDuration();
            }, 1000);
        }

        // Initialize
        updateStatus(false);
        updateMetrics();

        // Auto-create one test element for immediate testing
        setTimeout(() => {
            createTestElement();
            canvasDriftMonitor.log('info', 'Test environment ready. Create more elements or start monitoring to begin drift detection.');
        }, 500);
    </script>
</body>
</html>