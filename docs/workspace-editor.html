<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workspace Auto-Layout Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #58a6ff;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #21262d;
            color: #c9d1d9;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #30363d;
            border-color: #8b949e;
        }

        .btn-primary {
            background: #238636;
            border-color: #238636;
            color: #fff;
        }

        .btn-primary:hover {
            background: #2ea043;
        }

        .btn-accent {
            background: #58a6ff;
            border-color: #58a6ff;
            color: #000;
            font-weight: 600;
        }

        .btn-accent:hover {
            background: #79c0ff;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput {
            display: none;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 360px;
            background: #161b22;
            border-right: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #21262d;
        }

        .sidebar-section h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #8b949e;
            margin-bottom: 15px;
            letter-spacing: 0.5px;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-group label {
            display: block;
            font-size: 0.85rem;
            color: #8b949e;
            margin-bottom: 6px;
        }

        .config-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .config-row input[type="number"] {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #0d1117;
            color: #c9d1d9;
            font-size: 0.9rem;
        }

        .config-row input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #0d1117;
            color: #c9d1d9;
            font-size: 0.9rem;
        }

        /* Detection Result */
        .detection-result {
            background: #0d1117;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .detection-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .stat-box {
            background: #161b22;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #58a6ff;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #8b949e;
            margin-top: 4px;
        }

        .type-info {
            font-size: 0.8rem;
            color: #8b949e;
            line-height: 1.5;
        }

        .type-info span {
            color: #3fb950;
        }

        /* Layout Preview */
        .layout-preview {
            background: #0d1117;
            border-radius: 8px;
            padding: 15px;
        }

        .layout-calc {
            font-size: 0.8rem;
            line-height: 1.8;
        }

        .layout-calc .label {
            color: #8b949e;
        }

        .layout-calc .value {
            color: #58a6ff;
            font-weight: 600;
        }

        .layout-calc .good {
            color: #3fb950;
        }

        .layout-calc .warning {
            color: #d29922;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0d1117;
        }

        .canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        .workspace-canvas {
            position: relative;
            background: #161b22;
            min-width: 1920px;
            min-height: 1080px;
            transform-origin: 0 0;
        }

        .screen-indicator {
            position: absolute;
            border: 2px dashed #d29922;
            pointer-events: none;
            opacity: 0.5;
        }

        .screen-label {
            position: absolute;
            top: -25px;
            left: 0;
            font-size: 0.75rem;
            color: #d29922;
            white-space: nowrap;
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.2;
        }

        /* Display Element */
        .display-element {
            position: absolute;
            background: linear-gradient(135deg, #1c2128 0%, #161b22 100%);
            border: 2px solid #30363d;
            border-radius: 8px;
            cursor: move;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
            user-select: none;
        }

        .display-element.full-type {
            border-color: #3fb950;
        }

        .display-element.half-type {
            border-color: #a371f7;
        }

        .display-element:hover {
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.5);
        }

        .display-element.layout-preview {
            opacity: 0.7;
        }

        .display-header {
            padding: 8px 12px;
            background: #21262d;
            border-bottom: 1px solid #30363d;
            font-size: 0.85rem;
            font-weight: 600;
            color: #c9d1d9;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .display-element.full-type .display-header {
            background: rgba(63, 185, 80, 0.15);
        }

        .display-element.half-type .display-header {
            background: rgba(163, 113, 247, 0.15);
        }

        .display-source {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
            background: #30363d;
            color: #8b949e;
        }

        .display-body {
            flex: 1;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #8b949e;
        }

        .display-element.full-type .display-body::before {
            content: "‚ñÆ‚ñÆ";
            color: #3fb950;
            font-size: 1.2rem;
        }

        .display-element.half-type .display-body::before {
            content: "‚ñÆ";
            color: #a371f7;
            font-size: 1.2rem;
        }

        .display-dims {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.65rem;
            color: #484f58;
            background: rgba(0,0,0,0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 5px;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: #21262d;
            color: #c9d1d9;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .zoom-btn:hover {
            background: #30363d;
        }

        .zoom-level {
            padding: 0 12px;
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #8b949e;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #484f58;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state p {
            font-size: 1rem;
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .legend-color.full {
            background: #3fb950;
        }

        .legend-color.half {
            background: #a371f7;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1>Workspace Auto-Layout</h1>
            <div class="header-actions">
                <button class="btn" onclick="document.getElementById('fileInput').click()">üìÅ Load</button>
                <button class="btn" id="tidySizesBtn" disabled>üìê Tidy Sizes</button>
                <button class="btn" id="tidySpacingBtn" disabled>üìè Tidy Spacing</button>
                <button class="btn btn-accent" id="autoLayoutBtn" disabled>‚ö° Auto Layout</button>
                <button class="btn btn-primary" id="downloadBtn" disabled>üíæ Export</button>
                <input type="file" id="fileInput" accept=".json">
            </div>
        </div>
        <div style="font-size: 0.8rem; color: #8b949e;">
            <span id="fileInfo">No file loaded</span>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-section">
                <h3>üñ•Ô∏è Screen Settings</h3>

                <div class="config-group">
                    <label>Screen Resolution</label>
                    <div class="config-row">
                        <input type="number" id="screenWidth" value="1920" placeholder="Width">
                        <span>√ó</span>
                        <input type="number" id="screenHeight" value="1080" placeholder="Height">
                    </div>
                </div>

                <div class="config-group">
                    <label>Element Width (px)</label>
                    <div class="config-row">
                        <input type="number" id="elemWidth" value="220" min="150" max="400">
                    </div>
                </div>

                <div class="config-group">
                    <label>Gap Between Elements (px)</label>
                    <div class="config-row">
                        <input type="number" id="elementGap" value="10" min="0" max="50">
                    </div>
                </div>

                <div class="config-group">
                    <label>Margin from Screen Edge (px)</label>
                    <div class="config-row">
                        <input type="number" id="screenMargin" value="20" min="0" max="100">
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>üîç Auto-Detection</h3>

                <div class="detection-result" id="detectionResult">
                    <p style="color: #8b949e; text-align: center; padding: 20px;">
                        Load a workspace to detect types
                    </p>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color full"></div>
                        <span>Full Height</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color half"></div>
                        <span>Half Height</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>üìê Layout Calculation</h3>

                <div class="layout-preview" id="layoutPreview">
                    <p style="color: #8b949e; text-align: center; padding: 20px;">
                        Detection required first
                    </p>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                <div style="font-size: 0.75rem; color: #8b949e; line-height: 1.8;">
                    <div><kbd style="background:#21262d;padding:2px 6px;border-radius:3px;">Click</kbd> Select element</div>
                    <div><kbd style="background:#21262d;padding:2px 6px;border-radius:3px;">Drag</kbd> Move element</div>
                    <div><kbd style="background:#21262d;padding:2px 6px;border-radius:3px;">Ctrl+A</kbd> Select all</div>
                    <div><kbd style="background:#21262d;padding:2px 6px;border-radius:3px;">Del</kbd> Delete selected</div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="workspace-canvas" id="workspaceCanvas">
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-icon">üìä</div>
                        <p>Load a workspace JSON to begin</p>
                        <p style="font-size: 0.85rem; margin-top: 10px; color: #484f58;">
                            Auto-detects types ‚Ä¢ Smart layout ‚Ä¢ One-click arrange
                        </p>
                    </div>
                    <svg class="grid-overlay" id="gridOverlay"></svg>
                </div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">‚àí</button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomFit">‚ä°</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let originalData = null;
        let displays = [];
        let displayTypes = new Map(); // id -> 'full' | 'half'
        let detectedFullHeight = 350;
        let detectedHalfHeight = 174;
        let selectedElements = new Set();
        let zoom = 1;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let currentDragElement = null;

        // DOM Elements
        const canvas = document.getElementById('workspaceCanvas');
        const gridOverlay = document.getElementById('gridOverlay');
        const emptyState = document.getElementById('emptyState');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const downloadBtn = document.getElementById('downloadBtn');
        const tidySizesBtn = document.getElementById('tidySizesBtn');
        const tidySpacingBtn = document.getElementById('tidySpacingBtn');
        const autoLayoutBtn = document.getElementById('autoLayoutBtn');
        const detectionResult = document.getElementById('detectionResult');
        const layoutPreview = document.getElementById('layoutPreview');

        // File loading
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadFile(file);
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    originalData = JSON.parse(e.target.result);
                    displays = originalData.workspace.displays.map(d => ({
                        id: d[1].id,
                        symbol: d[1].symbol,
                        source: d[1].source,
                        x: d[1].position.x,
                        y: d[1].position.y,
                        width: d[1].size.width,
                        height: d[1].size.height,
                        zIndex: d[1].zIndex,
                        showMarketProfile: d[1].showMarketProfile,
                        showHeader: d[1].showHeader,
                        priceMarkers: d[1].priceMarkers
                    }));

                    fileInfo.textContent = `${file.name} (${displays.length} displays)`;
                    downloadBtn.disabled = false;
                    tidySizesBtn.disabled = false;
                    tidySpacingBtn.disabled = false;
                    autoLayoutBtn.disabled = false;
                    emptyState.style.display = 'none';

                    // Auto-detect types
                    detectTypes();

                    // Set canvas size to screen size
                    const screenWidth = parseInt(document.getElementById('screenWidth').value);
                    const screenHeight = parseInt(document.getElementById('screenHeight').value);
                    canvas.style.minWidth = screenWidth + 'px';
                    canvas.style.minHeight = screenHeight + 'px';

                    renderDisplays();
                    updateLayoutCalculation();
                    updateScreenIndicator();
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        // Auto-detect element types using clustering
        function detectTypes() {
            if (displays.length === 0) return;

            // Get all heights
            const heights = displays.map(d => d.height);

            // Use k-means clustering with k=2
            const clusters = kMeansCluster(heights, 2);

            // Determine which is full and which is half
            const cluster0Avg = clusters[0].reduce((a,b) => a+b, 0) / clusters[0].length;
            const cluster1Avg = clusters[1].reduce((a,b) => a+b, 0) / clusters[1].length;

            let fullCluster, halfCluster;
            if (cluster0Avg > cluster1Avg) {
                fullCluster = clusters[0];
                halfCluster = clusters[1];
            } else {
                fullCluster = clusters[1];
                halfCluster = clusters[0];
            }

            detectedFullHeight = Math.round(fullCluster.reduce((a,b) => a+b, 0) / fullCluster.length);
            detectedHalfHeight = Math.round(halfCluster.reduce((a,b) => a+b, 0) / halfCluster.length);

            // Assign types to displays
            displayTypes.clear();

            // Find threshold between clusters
            const threshold = (detectedFullHeight + detectedHalfHeight) / 2;

            displays.forEach(display => {
                const type = display.height >= threshold ? 'full' : 'half';
                displayTypes.set(display.id, type);
            });

            // Update detection result UI
            const fullCount = Array.from(displayTypes.values()).filter(t => t === 'full').length;
            const halfCount = Array.from(displayTypes.values()).filter(t => t === 'half').length;

            detectionResult.innerHTML = `
                <div class="detection-stats">
                    <div class="stat-box">
                        <div class="stat-value">${fullCount}</div>
                        <div class="stat-label">Full Height</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${halfCount}</div>
                        <div class="stat-label">Half Height</div>
                    </div>
                </div>
                <div class="type-info">
                    Detected: <span>${detectedHalfHeight}px</span> (half) and
                    <span>${detectedFullHeight}px</span> (full)
                </div>
            `;

            updateGridOverlay();
        }

        // Simple k-means clustering
        function kMeansCluster(data, k) {
            // Initialize centroids
            let centroids = [Math.min(...data), Math.max(...data)];

            for (let iter = 0; iter < 10; iter++) {
                // Assign to clusters
                const clusters = [[], []];

                data.forEach(point => {
                    const dist0 = Math.abs(point - centroids[0]);
                    const dist1 = Math.abs(point - centroids[1]);
                    if (dist0 < dist1) {
                        clusters[0].push(point);
                    } else {
                        clusters[1].push(point);
                    }
                });

                // Update centroids
                centroids[0] = clusters[0].length > 0
                    ? clusters[0].reduce((a,b) => a+b, 0) / clusters[0].length
                    : centroids[0];
                centroids[1] = clusters[1].length > 0
                    ? clusters[1].reduce((a,b) => a+b, 0) / clusters[1].length
                    : centroids[1];
            }

            // Final assignment
            const clusters = [[], []];
            data.forEach(point => {
                const dist0 = Math.abs(point - centroids[0]);
                const dist1 = Math.abs(point - centroids[1]);
                if (dist0 < dist1) {
                    clusters[0].push(point);
                } else {
                    clusters[1].push(point);
                }
            });

            return clusters;
        }

        // Calculate optimal layout
        function calculateLayout() {
            const screenWidth = parseInt(document.getElementById('screenWidth').value);
            const screenHeight = parseInt(document.getElementById('screenHeight').value);
            const elemWidth = parseInt(document.getElementById('elemWidth').value);
            const gap = parseInt(document.getElementById('elementGap').value);
            const margin = parseInt(document.getElementById('screenMargin').value);

            const fullWidth = elemWidth;
            const halfWidth = elemWidth;
            const fullHeight = detectedFullHeight;
            const halfHeight = detectedHalfHeight;

            // Count elements by type
            const fullCount = Array.from(displayTypes.values()).filter(t => t === 'full').length;
            const halfCount = Array.from(displayTypes.values()).filter(t => t === 'half').length;

            // Calculate columns that fit
            const availableWidth = screenWidth - 2 * margin;
            const columns = Math.floor((availableWidth + gap) / (elemWidth + gap));

            // Estimate rows needed
            const fullRows = Math.ceil(fullCount / columns);
            const halfRows = Math.ceil(halfCount / columns);

            // Calculate total height
            const totalFullHeight = fullRows * fullHeight + (fullRows - 1) * gap;
            const totalHalfHeight = halfRows * halfHeight + (halfRows - 1) * gap;
            const totalHeight = totalFullHeight + totalHalfHeight + gap;

            const fits = totalHeight <= screenHeight;

            return {
                screenWidth,
                screenHeight,
                elemWidth,
                gap,
                margin,
                columns,
                fullCount,
                halfCount,
                fullRows,
                halfRows,
                totalHeight,
                fits
            };
        }

        function updateLayoutCalculation() {
            if (displays.length === 0) return;

            const layout = calculateLayout();

            layoutPreview.innerHTML = `
                <div class="layout-calc">
                    <div><span class="label">Columns that fit:</span> <span class="value">${layout.columns}</span></div>
                    <div><span class="label">Full-height rows:</span> <span class="value">${layout.fullRows}</span></div>
                    <div><span class="label">Half-height rows:</span> <span class="value">${layout.halfRows}</span></div>
                    <div><span class="label">Total height:</span> <span class="value">${layout.totalHeight}px</span></div>
                    <div><span class="label">Screen height:</span> <span class="value">${layout.screenHeight}px</span></div>
                    <div style="margin-top: 10px;">
                        <span class="label">Fits on screen:</span>
                        <span class="${layout.fits ? 'good' : 'warning'}">
                            ${layout.fits ? '‚úì Yes' : '‚ö† No (overflow: ' + (layout.totalHeight - layout.screenHeight) + 'px)'}
                        </span>
                    </div>
                </div>
            `;
        }

        function renderDisplays() {
            // Remove existing
            canvas.querySelectorAll('.display-element').forEach(el => el.remove());

            displays.forEach(display => {
                const type = displayTypes.get(display.id) || 'half';
                const el = createDisplayElement(display, type);
                canvas.appendChild(el);
            });
        }

        function createDisplayElement(display, type) {
            const el = document.createElement('div');
            el.className = `display-element ${type}-type`;
            el.dataset.id = display.id;
            el.style.left = display.x + 'px';
            el.style.top = display.y + 'px';
            el.style.width = display.width + 'px';
            el.style.height = display.height + 'px';
            el.style.zIndex = display.zIndex || 1;

            el.innerHTML = `
                <div class="display-header">
                    <span>${display.symbol}</span>
                    <span class="display-source">${display.source}</span>
                </div>
                <div class="display-body"></div>
                <div class="display-dims">${Math.round(display.width)}√ó${Math.round(display.height)}</div>
            `;

            el.addEventListener('mousedown', handleElementMouseDown);
            el.addEventListener('click', handleElementClick);

            return el;
        }

        function handleElementClick(e) {
            if (isDragging) return;

            const el = e.currentTarget;
            const id = el.dataset.id;

            if (e.ctrlKey || e.metaKey) {
                if (selectedElements.has(id)) {
                    selectedElements.delete(id);
                } else {
                    selectedElements.add(id);
                }
            } else {
                canvas.querySelectorAll('.display-element.selected').forEach(elem => {
                    elem.classList.remove('selected');
                });
                selectedElements.clear();
                selectedElements.add(id);
            }

            el.classList.toggle('selected', selectedElements.has(id));
            e.stopPropagation();
        }

        function handleElementMouseDown(e) {
            isDragging = true;
            currentDragElement = e.currentTarget;

            const rect = currentDragElement.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            const startX = e.clientX;
            const startY = e.clientY;
            const origLeft = parseFloat(currentDragElement.style.left);
            const origTop = parseFloat(currentDragElement.style.top);

            const handleMouseMove = (e) => {
                if (!isDragging) return;

                const newX = origLeft + (e.clientX - startX) / zoom;
                const newY = origTop + (e.clientY - startY) / zoom;

                currentDragElement.style.left = Math.max(0, newX) + 'px';
                currentDragElement.style.top = Math.max(0, newY) + 'px';
            };

            const handleMouseUp = () => {
                isDragging = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                syncElementData(currentDragElement);
                snapToScreen(currentDragElement);
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            e.stopPropagation();
        }

        function syncElementData(el) {
            const id = el.dataset.id;
            const display = displays.find(d => d.id === id);
            if (display) {
                display.x = parseFloat(el.style.left);
                display.y = parseFloat(el.style.top);
                display.width = parseFloat(el.style.width);
                display.height = parseFloat(el.style.height);
            }
        }

        function snapToScreen(el) {
            const margin = parseInt(document.getElementById('screenMargin').value);
            const screenWidth = parseInt(document.getElementById('screenWidth').value);
            const screenHeight = parseInt(document.getElementById('screenHeight').value);

            let x = parseFloat(el.style.left);
            let y = parseFloat(el.style.top);
            const width = parseFloat(el.style.width);
            const height = parseFloat(el.style.height);

            // Snap to edges
            if (x < margin) x = margin;
            if (y < margin) y = margin;
            if (x + width > screenWidth - margin) x = screenWidth - margin - width;
            if (y + height > screenHeight - margin) y = screenHeight - margin - height;

            el.style.left = x + 'px';
            el.style.top = y + 'px';

            syncElementData(el);
        }

        // Tidy Sizes - Make element sizes consistent, keep positions
        function tidySizes() {
            if (displays.length === 0) return;

            const elemWidth = parseInt(document.getElementById('elemWidth').value);

            displays.forEach(display => {
                const el = canvas.querySelector(`[data-id="${display.id}"]`);
                const type = displayTypes.get(display.id);
                const height = type === 'full' ? detectedFullHeight : detectedHalfHeight;

                display.width = elemWidth;
                display.height = height;

                if (el) {
                    el.style.width = elemWidth + 'px';
                    el.style.height = height + 'px';
                    el.querySelector('.display-dims').textContent = `${elemWidth}√ó${height}`;
                }
            });
        }

        // Tidy Spacing - Snap all elements to macro grid
        // Grid cell size = half-height, full-height elements span 2 cells
        function tidySpacing() {
            if (displays.length === 0) return;

            const gap = parseInt(document.getElementById('elementGap').value);
            const elemWidth = parseInt(document.getElementById('elemWidth').value);
            const margin = parseInt(document.getElementById('screenMargin').value);

            // Macro grid dimensions
            // Grid cell = half-height element + gap (so stacked halves align properly)
            const gridCellHeight = detectedHalfHeight + gap;
            const gridCellWidth = elemWidth + gap;

            // Map to track occupied grid positions: "x,y" -> displayId
            const occupiedPositions = new Map();

            // Sort displays by Y then X to process top-to-bottom, left-to-right
            const sortedDisplays = [...displays].sort((a, b) => {
                if (Math.abs(a.y - b.y) < 20) return a.x - b.x;
                return a.y - b.y;
            });

            sortedDisplays.forEach(display => {
                const type = displayTypes.get(display.id);
                const isFull = type === 'full';

                // Calculate current grid position
                const currentGridX = Math.round(display.x / gridCellWidth);
                const currentGridY = Math.round(display.y / gridCellHeight);

                // Find nearest available grid position
                let gridX = currentGridX;
                let gridY = currentGridY;

                // Check for collisions and find nearest empty slot
                let searchRadius = 0;
                const maxSearch = 20;
                let foundPosition = null;

                while (!foundPosition && searchRadius < maxSearch) {
                    // Search in expanding square pattern
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                            const testX = currentGridX + dx;
                            const testY = currentGridY + dy;

                            // Check if this position (and below for full-height) is free
                            if (isPositionFree(testX, testY, occupiedPositions, isFull)) {
                                foundPosition = { x: testX, y: testY };
                                break;
                            }
                        }
                        if (foundPosition) break;
                    }
                    searchRadius++;
                }

                if (foundPosition) {
                    gridX = foundPosition.x;
                    gridY = foundPosition.y;
                }

                // Mark positions as occupied
                occupiedPositions.set(`${gridX},${gridY}`, display.id);
                if (isFull) {
                    occupiedPositions.set(`${gridX},${gridY + 1}`, display.id);
                }

                // Convert grid position back to pixel coordinates
                const newX = margin + gridX * gridCellWidth;
                const newY = margin + gridY * gridCellHeight;

                // Apply to display
                const el = canvas.querySelector(`[data-id="${display.id}"]`);
                display.x = newX;
                display.y = newY;
                display.width = elemWidth;

                if (el) {
                    el.style.left = newX + 'px';
                    el.style.top = newY + 'px';
                    el.style.width = elemWidth + 'px';
                    el.querySelector('.display-dims').textContent = `${elemWidth}√ó${Math.round(display.height)}`;
                }
            });
        }

        // Check if a grid position is free
        function isPositionFree(gridX, gridY, occupied, isFull) {
            if (gridX < 0 || gridY < 0) return false;

            const key = `${gridX},${gridY}`;
            const occupiedBy = occupied.get(key);

            // If same element already there, it's fine
            if (occupiedBy) {
                // Check if it's the same element trying to stay in place
                // This allows slight adjustments without collision
                return true;
            }

            // For full-height, also check the cell below
            if (isFull) {
                const keyBelow = `${gridX},${gridY + 1}`;
                if (occupied.has(keyBelow)) return false;
            }

            return !occupied.has(key);
        }

        // Detect rows by clustering Y positions
        function detectRows() {
            const rowGroups = new Map();
            const rowThreshold = detectedFullHeight * 0.5;

            displays.forEach(display => {
                let foundRow = null;
                for (const [rowY, elements] of rowGroups) {
                    const rowAvgY = elements.reduce((sum, d) => sum + d.y, 0) / elements.length;
                    if (Math.abs(display.y - rowAvgY) < rowThreshold) {
                        foundRow = rowY;
                        break;
                    }
                }

                if (foundRow !== null) {
                    rowGroups.get(foundRow).push(display);
                } else {
                    rowGroups.set(display.y, [display]);
                }
            });

            return Array.from(rowGroups.values())
                .sort((a, b) => a[0].y - b[0].y);
        }

        // Detect columns within a row by clustering X positions
        function detectColumns(row) {
            const columnGroups = new Map();
            const elemWidth = parseInt(document.getElementById('elemWidth').value);
            const colThreshold = elemWidth * 1.5;

            row.forEach(display => {
                let foundCol = null;
                for (const [colX, elements] of columnGroups) {
                    const colAvgX = elements.reduce((sum, d) => sum + d.x, 0) / elements.length;
                    if (Math.abs(display.x - colAvgX) < colThreshold) {
                        foundCol = colX;
                        break;
                    }
                }

                if (foundCol !== null) {
                    columnGroups.get(foundCol).push(display);
                } else {
                    columnGroups.set(display.x, [display]);
                }
            });

            return Array.from(columnGroups.values())
                .sort((a, b) => a[0].x - b[0].x);
        }

        // Auto Layout - Full re-layout with smart grid detection
        autoLayoutBtn.addEventListener('click', () => {
            // First tidy sizes
            tidySizes();

            if (displays.length === 0) return;

            const gap = parseInt(document.getElementById('elementGap').value);
            const margin = parseInt(document.getElementById('screenMargin').value);
            const elemWidth = parseInt(document.getElementById('elemWidth').value);
            const halfHeight = detectedHalfHeight;
            const fullHeight = detectedFullHeight;

            // Detect grid slots (full elements or stacked half pairs)
            const gridSlots = detectGridSlots(elemWidth, halfHeight);

            // Group slots by rows
            const rowGroups = new Map();
            gridSlots.forEach(slot => {
                const slotY = slot.y;
                const rowThreshold = fullHeight * 0.5;

                let foundRow = null;
                for (const [rowY, slots] of rowGroups) {
                    const rowAvgY = slots.reduce((sum, s) => sum + s.y, 0) / slots.length;
                    if (Math.abs(slotY - rowAvgY) < rowThreshold) {
                        foundRow = rowY;
                        break;
                    }
                }

                if (foundRow !== null) {
                    rowGroups.get(foundRow).push(slot);
                } else {
                    rowGroups.set(slotY, [slot]);
                }
            });

            const rows = Array.from(rowGroups.values())
                .sort((a, b) => a[0].y - b[0].y);

            // Layout rows with consistent spacing
            let currentY = margin;

            rows.forEach(row => {
                // Sort slots by X position to preserve order
                row.sort((a, b) => a.x - b.x);

                let currentX = margin;

                row.forEach(slot => {
                    // Position each display in the slot
                    slot.displays.forEach((display, idx) => {
                        const el = canvas.querySelector(`[data-id="${display.id}"]`);

                        display.x = currentX;
                        display.width = elemWidth;

                        // Stack half-height elements vertically
                        if (idx === 0) {
                            display.y = currentY;
                        } else {
                            display.y = currentY + halfHeight + gap;
                        }

                        if (el) {
                            el.style.left = currentX + 'px';
                            el.style.top = display.y + 'px';
                            el.style.width = elemWidth + 'px';
                        }
                    });

                    currentX += elemWidth + gap;
                });

                // Move to next row
                currentY += fullHeight + gap;
            });

            updateLayoutCalculation();
        });

        // Grid overlay - Show macro grid
        function updateGridOverlay() {
            const gap = parseInt(document.getElementById('elementGap').value);
            const elemWidth = parseInt(document.getElementById('elemWidth').value);
            const width = 2500;
            const height = 2000;

            // Macro grid: cell width = elemWidth + gap, cell height = halfHeight + gap
            const gridCellWidth = elemWidth + gap;
            const gridCellHeight = detectedHalfHeight + gap;

            let svg = '';

            // Draw vertical lines at column positions
            for (let x = 0; x <= width; x += gridCellWidth) {
                svg += `<line x1="${x}" y1="0" x2="${x}" y2="${height}" stroke="#30363d" stroke-width="1"/>`;
            }

            // Draw horizontal lines at row positions
            for (let y = 0; y <= height; y += gridCellHeight) {
                svg += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="#30363d" stroke-width="1"/>`;
            }

            gridOverlay.innerHTML = svg;
        }

        function updateScreenIndicator() {
            // Remove old indicator
            canvas.querySelectorAll('.screen-indicator').forEach(el => el.remove());

            const screenWidth = parseInt(document.getElementById('screenWidth').value);
            const screenHeight = parseInt(document.getElementById('screenHeight').value);

            const indicator = document.createElement('div');
            indicator.className = 'screen-indicator';
            indicator.style.width = screenWidth + 'px';
            indicator.style.height = screenHeight + 'px';
            indicator.style.left = '0';
            indicator.style.top = '0';
            indicator.innerHTML = `<div class="screen-label">Screen: ${screenWidth}√ó${screenHeight}</div>`;

            canvas.appendChild(indicator);
        }

        // Update layout when settings change
        ['screenWidth', 'screenHeight', 'elemWidth', 'elementGap', 'screenMargin'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                updateLayoutCalculation();
                updateScreenIndicator();
                updateGridOverlay();
            });
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => {
            zoom = Math.min(2, zoom + 0.1);
            updateZoom();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            zoom = Math.max(0.25, zoom - 0.1);
            updateZoom();
        });

        document.getElementById('zoomFit').addEventListener('click', () => {
            zoom = 1;
            updateZoom();
        });

        function updateZoom() {
            canvas.style.transform = `scale(${zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        // Export
        downloadBtn.addEventListener('click', () => {
            if (!originalData) return;

            const formattedDisplays = displays.map(d => {
                const type = displayTypes.get(d.id);
                return [
                    d.id,
                    {
                        id: d.id,
                        symbol: d.symbol,
                        source: d.source,
                        created: originalData.workspace.displays.find(item => item[1].id === d.id)?.[1].created || Date.now(),
                        position: { x: Math.round(d.x), y: Math.round(d.y) },
                        size: { width: Math.round(d.width), height: Math.round(d.height) },
                        zIndex: d.zIndex || 1,
                        showMarketProfile: d.showMarketProfile,
                        showHeader: d.showHeader,
                        priceMarkers: d.priceMarkers
                    }
                ];
            });

            const output = {
                ...originalData,
                workspace: {
                    ...originalData.workspace,
                    displays: formattedDisplays
                }
            };

            const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workspace-auto-layout.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Tidy Sizes button
        tidySizesBtn.addEventListener('click', tidySizes);

        // Tidy Spacing button
        tidySpacingBtn.addEventListener('click', tidySpacing);

        // Click canvas to deselect
        canvas.addEventListener('click', (e) => {
            if (e.target === canvas || e.target === gridOverlay) {
                selectedElements.forEach(id => {
                    const el = canvas.querySelector(`[data-id="${id}"]`);
                    if (el) el.classList.remove('selected');
                });
                selectedElements.clear();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'a') {
                    e.preventDefault();
                    canvas.querySelectorAll('.display-element').forEach(el => {
                        el.classList.add('selected');
                        selectedElements.add(el.dataset.id);
                    });
                }
            }
        });

        // Initialize
        updateScreenIndicator();
    </script>
</body>
</html>
