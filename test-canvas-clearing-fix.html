<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Clearing Fix Test</title>
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #1a1a1a;
            color: #ffffff;
            margin: 0;
            padding: 20px;
        }
        .test-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .canvas-container {
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
        }
        canvas {
            background-color: #111827;
            border: 1px solid #333;
            display: block;
            margin: 10px 0;
        }
        .controls {
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background-color: #45a049;
        }
        .status {
            background-color: #444;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .result {
            margin: 5px 0;
            padding: 5px;
        }
        .pass { color: #4CAF50; }
        .fail { color: #f44336; }
        .info { color: #2196F3; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Canvas Clearing Fix Test</h1>
        <p>This test verifies the canvas clearing coordinate fix for DPR scaling.</p>

        <div class="controls">
            <button onclick="runClearingTest()">Run Canvas Clearing Test</button>
            <button onclick="runRenderCycleTest()">Run Render Cycle Test</button>
            <button onclick="clearResults()">Clear Results</button>
        </div>

        <div class="status" id="results">
            <div class="result info">Click buttons above to run tests...</div>
        </div>

        <div class="canvas-container">
            <h3>Test Canvas</h3>
            <canvas id="testCanvas" width="400" height="300"></canvas>
            <div>
                <strong>DPR:</strong> <span id="dprInfo"></span><br>
                <strong>Canvas Size:</strong> <span id="canvasSizeInfo"></span><br>
                <strong>Display Size:</strong> <span id="displaySizeInfo"></span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const results = document.getElementById('results');
        const dprInfo = document.getElementById('dprInfo');
        const canvasSizeInfo = document.getElementById('canvasSizeInfo');
        const displaySizeInfo = document.getElementById('displaySizeInfo');

        // Initialize canvas information
        function updateInfo() {
            const dpr = window.devicePixelRatio || 1;
            dprInfo.textContent = dpr;
            canvasSizeInfo.textContent = `${canvas.width}x${canvas.height}`;
            displaySizeInfo.textContent = `${canvas.clientWidth}x${canvas.clientHeight}`;
        }

        updateInfo();

        function addResult(message, type = 'info') {
            const result = document.createElement('div');
            result.className = `result ${type}`;
            result.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            results.appendChild(result);
        }

        function clearResults() {
            results.innerHTML = '';
        }

        // Simulate the original buggy canvas clearing
        function clearCanvasBuggy() {
            // This is the buggy approach - not dividing by DPR
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Simulate the fixed canvas clearing
        function clearCanvasFixed() {
            const dpr = window.devicePixelRatio || 1;
            const clearWidth = canvas.width / dpr;
            const clearHeight = canvas.height / dpr;

            ctx.clearRect(0, 0, clearWidth, clearHeight);
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, clearWidth, clearHeight);
        }

        function drawTestContent(offsetX = 0, offsetY = 0) {
            // Apply DPR scaling (simulating the Container.svelte approach)
            const dpr = window.devicePixelRatio || 1;
            ctx.save();
            ctx.scale(dpr, dpr);

            // Draw some test content at different positions
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(10 + offsetX, 10 + offsetY, 50, 30);

            ctx.fillStyle = '#4ecdc4';
            ctx.fillRect(100 + offsetX, 20 + offsetY, 40, 40);

            ctx.fillStyle = '#45b7d1';
            ctx.fillRect(180 + offsetX, 15 + offsetY, 60, 35);

            // Draw some text
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.fillText('Test Content', 10 + offsetX, 80 + offsetY);

            ctx.restore();
        }

        function runClearingTest() {
            addResult('Starting canvas clearing test...', 'info');

            // Test with multiple render cycles to simulate drift
            let driftDetected = false;
            const snapshots = [];

            for (let i = 0; i < 10; i++) {
                // Clear using fixed method
                clearCanvasFixed();

                // Draw content with slight offsets to simulate market data updates
                drawTestContent(i * 0.5, i * 0.3);

                // Capture snapshot for analysis
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                snapshots.push(imageData);
            }

            // Analyze for accumulation artifacts (signs of incomplete clearing)
            const finalSnapshot = snapshots[snapshots.length - 1];
            let nonBackgroundPixels = 0;

            for (let i = 0; i < finalSnapshot.data.length; i += 4) {
                // Check if pixel is not the background color (#111827 = rgb(17,24,39))
                const r = finalSnapshot.data[i];
                const g = finalSnapshot.data[i + 1];
                const b = finalSnapshot.data[i + 2];

                if (r > 17 || g > 24 || b > 39) {
                    nonBackgroundPixels++;
                }
            }

            const totalPixels = (canvas.width * canvas.height);
            const contentPercentage = (nonBackgroundPixels / totalPixels) * 100;

            if (contentPercentage < 50) {
                addResult(`✓ Canvas clearing works correctly: ${contentPercentage.toFixed(1)}% content pixels`, 'pass');
            } else {
                addResult(`✗ Canvas clearing may have issues: ${contentPercentage.toFixed(1)}% content pixels`, 'fail');
                driftDetected = true;
            }

            // Test the buggy method for comparison
            addResult('Testing original buggy method for comparison...', 'info');
            clearCanvasBuggy();
            drawTestContent(100, 100);

            const buggyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let buggyNonBackgroundPixels = 0;

            for (let i = 0; i < buggyImageData.data.length; i += 4) {
                const r = buggyImageData.data[i];
                const g = buggyImageData.data[i + 1];
                const b = buggyImageData.data[i + 2];

                if (r > 17 || g > 24 || b > 39) {
                    buggyNonBackgroundPixels++;
                }
            }

            const buggyPercentage = (buggyNonBackgroundPixels / totalPixels) * 100;
            addResult(`Buggy method result: ${buggyPercentage.toFixed(1)}% content pixels`, 'info');

            addResult('Canvas clearing test completed', 'info');
        }

        function runRenderCycleTest() {
            addResult('Starting render cycle test...', 'info');

            // Test multiple render cycles to check for cumulative effects
            let previousSnapshot = null;
            let maxDrift = 0;

            for (let cycle = 0; cycle < 20; cycle++) {
                // Clear using fixed method
                clearCanvasFixed();

                // Draw content
                const offsetX = Math.sin(cycle * 0.1) * 5;
                const offsetY = Math.cos(cycle * 0.1) * 5;
                drawTestContent(offsetX, offsetY);

                // Capture snapshot
                const currentSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);

                if (previousSnapshot) {
                    // Compare with previous to detect drift
                    let differences = 0;
                    for (let i = 0; i < currentSnapshot.data.length; i += 4) {
                        const diff = Math.abs(currentSnapshot.data[i] - previousSnapshot.data[i]) +
                                    Math.abs(currentSnapshot.data[i + 1] - previousSnapshot.data[i + 1]) +
                                    Math.abs(currentSnapshot.data[i + 2] - previousSnapshot.data[i + 2]);
                        if (diff > 30) differences++;
                    }

                    const driftPercentage = (differences / (canvas.width * canvas.height)) * 100;
                    maxDrift = Math.max(maxDrift, driftPercentage);
                }

                previousSnapshot = currentSnapshot;
            }

            if (maxDrift < 25) {
                addResult(`✓ Render cycles stable: max drift ${maxDrift.toFixed(1)}%`, 'pass');
            } else {
                addResult(`⚠ Render cycles show high variation: max drift ${maxDrift.toFixed(1)}%`, 'fail');
            }

            addResult('Render cycle test completed', 'info');
        }

        // Initial draw
        clearCanvasFixed();
        drawTestContent();
        addResult('Canvas initialized with fixed clearing method', 'info');
    </script>
</body>
</html>