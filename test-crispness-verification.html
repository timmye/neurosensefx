<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚úÖ Crispness Verification Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1f2937;
            color: #d1d5db;
        }
        
        .test-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .test-section {
            border: 1px solid #374151;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        
        .test-section h3 {
            margin: 0 0 10px 0;
            color: #10b981;
        }
        
        .test-results {
            background: #111827;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            margin: 10px 0;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 10px 0;
        }
        
        canvas {
            border: 1px solid #4b5563;
            background: #000000;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        
        .status-success {
            background: #065f46;
            color: white;
            padding: 10px;
        }
        
        .status-warning {
            background: #f59e0b;
            color: white;
            padding: 10px;
        }
        
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #2563eb;
        }
    </style>
</head>
<body>
    <h1>‚úÖ Crispness Verification Test</h1>
    <p>Tests the pixel-perfect canvas rendering fixes across all NeuroSense FX visualizations.</p>
    
    <div class="test-container">
        <div class="test-section">
            <h3>üìä Test 1: Standard Display (220√ó160px)</h3>
            <div class="canvas-container">
                <canvas id="standardCanvas" width="240" height="160"></canvas>
            </div>
            <div id="standardResults" class="test-results"></div>
            <div id="standardStatus" class="status"></div>
        </div>
        
        <div class="test-section">
            <h3>üìä Test 2: Fractional Display (244.51√ó156.08px)</h3>
            <div class="canvas-container">
                <canvas id="fractionalCanvas" width="245" height="156"></canvas>
            </div>
            <div id="fractionalResults" class="test-results"></div>
            <div id="fractionalStatus" class="status"></div>
        </div>
        
        <div class="test-section">
            <h3>üîß Test Controls</h3>
            <button onclick="runStandardTest()">üìä Run Standard Test</button>
            <button onclick="runFractionalTest()">üìä Run Fractional Test</button>
            <button onclick="runBothTests()">üìä Run Both Tests</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>
    </div>

    <script>
        class CrispnessTest {
            constructor() {
                this.standardCanvas = document.getElementById('standardCanvas');
                this.fractionalCanvas = document.getElementById('fractionalCanvas');
                this.standardCtx = this.standardCanvas.getContext('2d');
                this.fractionalCtx = this.fractionalCanvas.getContext('2d');
                
                this.setupTest();
            }
            
            setupTest() {
                // Test configuration
                this.testConfig = {
                    symbol: 'TEST',
                    contentArea: { width: 220, height: 120 },
                    adrAxisX: 143, // 65% of 220px
                    midPrice: 1.0845,
                    currentPrice: 1.0850,
                    todaysHigh: 1.0860,
                    todaysLow: 1.0830,
                    projectedAdrHigh: 1.0870,
                    projectedAdrLow: 1.0820,
                    digits: 5
                };
            }
            
            async runStandardTest() {
                this.showStatus('Running Standard Test...');
                await this.testCrispness(this.standardCtx, 'Standard Display');
                this.showResults('standardResults', 'Standard Display');
                this.updateStatus('standardStatus', 'success');
            }
            
            async runFractionalTest() {
                this.showStatus('Running Fractional Test...');
                await this.testCrispness(this.fractionalCtx, 'Fractional Display');
                this.showResults('fractionalResults', 'Fractional Display');
                this.updateStatus('fractionalStatus', 'warning');
            }
            
            async runBothTests() {
                this.showStatus('Running Both Tests...');
                await Promise.all([
                    this.testCrispness(this.standardCtx, 'Standard Display'),
                    this.testCrispness(this.fractionalCtx, 'Fractional Display')
                ]);
                this.showResults('standardResults', 'Standard Display');
                this.showResults('fractionalResults', 'Fractional Display');
                
                // Compare results
                const standardResult = this.getLastResult('standardResults');
                const fractionalResult = this.getLastResult('fractionalResults');
                
                if (standardResult.isPixelPerfect && fractionalResult.isPixelPerfect) {
                    this.updateStatus('standardStatus', 'success');
                    this.updateStatus('fractionalStatus', 'success');
                } else if (standardResult.isPixelPerfect && !fractionalResult.isPixelPerfect) {
                    this.updateStatus('standardStatus', 'success');
                    this.updateStatus('fractionalStatus', 'warning');
                } else if (!standardResult.isPixelPerfect && fractionalResult.isPixelPerfect) {
                    this.updateStatus('standardStatus', 'warning');
                    this.updateStatus('fractionalStatus', 'success');
                } else {
                    this.updateStatus('standardStatus', 'warning');
                    this.updateStatus('fractionalStatus', 'warning');
                }
            }
            
            async testCrispness(ctx, testName) {
                const results = await this.performCrispnessTest(ctx, testName);
                return results;
            }
            
            async performCrispnessTest(ctx, testName) {
                // Clear canvas
                ctx.clearRect(0, 0, this.testConfig.contentArea.width, this.testConfig.contentArea.height);
                
                // Draw test elements
                const results = {
                    textRendering: this.testTextRendering(ctx),
                    lineRendering: this.testLineRendering(ctx),
                    dimensions: this.testCanvasDimensions(ctx),
                    rendering: this.testOverallRendering(ctx)
                };
                
                // Draw test visualizations
                this.drawTestVisualizations(ctx);
                
                return results;
            }
            
            testTextRendering(ctx) {
                const textResults = [];
                
                // Test 1: Basic text rendering
                ctx.save();
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textBaseline = 'middle';
                
                const testText = 'CRISP TEXT 12px';
                ctx.fillText(testText, 110, 60);
                
                // Check if text is rendered (should be crisp)
                const imageData = ctx.getImageData(108, 40, 140, 60);
                const textPixels = [];
                
                for (let x = 108; x < 140; x++) {
                    for (let y = 40; y < 60; y++) {
                        const pixel = ctx.getImageData(x, y, 1, 1, 1).data;
                        const isText = pixel[3] === 255 && pixel[0] === 255 && pixel[1] === 255 && pixel[2] === 255;
                        if (isText) textPixels.push({x, y});
                    }
                }
                
                const isTextCrisp = textPixels.length > 0;
                textResults.push({
                    test: 'Basic Text Rendering',
                    passed: isTextCrisp,
                    details: `Found ${textPixels.length} text pixels`
                });
                
                ctx.restore();
                return {
                    passed: isTextCrisp,
                    details: textResults
                };
            }
            
            testLineRendering(ctx) {
                const lineResults = [];
                
                // Test 2: Horizontal line rendering
                ctx.save();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, 60);
                ctx.lineTo(170, 60);
                ctx.stroke();
                
                // Check if line is crisp (should be 1px)
                const lineData = [];
                for (let x = 50; x < 170; x++) {
                    const pixel = ctx.getImageData(x, 59, 1, 1, 1).data;
                    const isLine = pixel[3] === 255 && (pixel[0] === 0 || pixel[1] === 0 || pixel[2] === 0);
                    if (isLine) lineData.push({x, y});
                }
                
                const isLineCrisp = lineData.length > 0;
                lineResults.push({
                    test: 'Horizontal Line Rendering',
                    passed: isLineCrisp,
                    details: `Found ${lineData.length} crisp line pixels`
                });
                
                ctx.restore();
                return {
                    passed: isLineCrisp,
                    details: lineResults
                };
            }
            
            testCanvasDimensions(ctx) {
                const dpr = window.devicePixelRatio || 1;
                const canvasWidth = ctx.canvas.width;
                const canvasHeight = ctx.canvas.height;
                const cssWidth = canvasWidth / dpr;
                const cssHeight = canvasHeight / dpr;
                
                // Check if dimensions are pixel-perfect (should be integers)
                const isWidthInteger = Number.isInteger(canvasWidth);
                const isHeightInteger = Number.isInteger(canvasHeight);
                
                return {
                    passed: isWidthInteger && isHeightInteger,
                    details: `Canvas: ${canvasWidth}√ó${canvasHeight}, CSS: ${cssWidth}√ó${cssHeight}, DPR: ${dpr}`
                };
            }
            
            testOverallRendering(ctx) {
                // Test 3: Complete rendering pipeline
                this.drawTestVisualizations(ctx);
                
                // Check overall rendering quality
                const imageData = ctx.getImageData(0, 0, this.testConfig.contentArea.width, this.testConfig.contentArea.height);
                const hasContent = imageData.data.some(pixel => pixel[3] !== 0);
                
                return {
                    passed: hasContent,
                    details: hasContent ? 'Canvas has content' : 'Canvas appears empty'
                };
            }
            
            drawTestVisualizations(ctx) {
                // Draw ADR axis (should be crisp 1px line)
                ctx.save();
                ctx.strokeStyle = '#4B5563';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.testConfig.adrAxisX, 0);
                ctx.lineTo(this.testConfig.adrAxisX, this.testConfig.contentArea.height);
                ctx.stroke();
                
                // Draw price markers (should be crisp text)
                ctx.save();
                ctx.font = '10px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'right';
                
                const priceLabels = [
                    { text: 'O 1.0845', y: 60 },
                    { text: 'H 1.0860', y: 40 },
                    { text: 'L 1.0830', y: 80 },
                    { text: 'C 1.0850', y: 20 }
                ];
                
                priceLabels.forEach(label => {
                    ctx.fillText(label.text, this.testConfig.adrAxisX - 15, label.y);
                });
                
                ctx.restore();
            }
            
            showResults(elementId, testName) {
                const results = this.getLastResult(elementId);
                const html = results.details.map(result => 
                    `<div><strong>${result.test}:</strong> ${result.passed ? '‚úÖ PASS' : '‚ùå FAIL'} - ${result.details}</div>`
                ).join('');
                
                document.getElementById(elementId).innerHTML = html;
            }
            
            getLastResult(elementId) {
                const element = document.getElementById(elementId);
                const statusElement = element.nextElementSibling;
                
                return {
                    isPixelPerfect: statusElement?.className.includes('success'),
                    details: element?.innerHTML || ''
                };
            }
            
            showStatus(elementId, status) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.className = `status ${status}`;
                    element.textContent = status;
                }
            }
            
            updateStatus(elementId, status) {
                this.showStatus(elementId, status);
            }
            
            clearResults() {
                document.getElementById('standardResults').innerHTML = '';
                document.getElementById('fractionalResults').innerHTML = '';
                this.updateStatus('standardStatus', '');
                this.updateStatus('fractionalStatus', '');
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new CrispnessTest();
        });
    </script>
</body>
</html>
++++++ REPLACE
</diff>
<task_progress>
- [x] Fix canvasSizing.js with enhanced DPR utilities
- [x] Update FloatingDisplay.svelte canvas initialization
- [x] Fix dayRangeMeter.js text rendering
- [x] Update volatilityOrb.js rendering consistency
- [x] Fix priceDisplay.js font sizing
- [x] Update priceFloat.js consistency
- [x] Update marketProfile.js with enhanced text
- [ ] Test crispness across all visualizations
</task_progress>
</replace_in_file>
