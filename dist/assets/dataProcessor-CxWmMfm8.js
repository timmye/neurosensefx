(function(){"use strict";console.log("Worker started");let a={},e={};self.onmessage=t=>{const{type:c,payload:i}=t.data;switch(c){case"init":f(i);break;case"tick":p(i);break;case"initialProfile":k(i);break;case"updateConfig":a={...a,...i};break}};function f(t){a=t.config;const c=t.midPrice||0;e={currentPrice:c,midPrice:c,minObservedPrice:c,maxObservedPrice:c,ticks:[],allTicks:[],volatility:.5,tickMagnitudes:[],lastTickDirection:"up",adrHigh:c*1.005,adrLow:c*.995}}function k(t){const c=performance.now();e.allTicks=t.map(r=>({price:r.price,direction:1,magnitude:0,time:c}));const i=u();self.postMessage({type:"stateUpdate",payload:{newState:e,marketProfile:i,flashEffect:null}})}function p(t){if(!t||typeof t.bid!="number")return;e.midPrice===0&&(e.midPrice=t.bid,e.minObservedPrice=t.bid,e.maxObservedPrice=t.bid);const c=e.currentPrice;e.currentPrice=t.bid,e.lastTickDirection=e.currentPrice>c?"up":"down";const i=Math.abs(e.currentPrice-c)*1e4,r=performance.now(),n={price:e.currentPrice,direction:e.lastTickDirection==="up"?1:-1,magnitude:i,time:r};e.ticks.push(n),e.allTicks.push(n),e.tickMagnitudes.push(i),e.minObservedPrice=Math.min(e.minObservedPrice,e.currentPrice),e.maxObservedPrice=Math.max(e.maxObservedPrice,e.currentPrice),m();const s=u();let o=null;(a.showFlash&&i>=a.flashThreshold||a.showOrbFlash&&i>=a.orbFlashThreshold)&&(o={magnitude:i,direction:e.lastTickDirection}),self.postMessage({type:"stateUpdate",payload:{newState:{currentPrice:e.currentPrice,lastTickDirection:e.lastTickDirection,volatility:e.volatility},marketProfile:s,flashEffect:o}})}function m(){const c=performance.now();if(e.ticks=e.ticks.filter(l=>c-l.time<=1e4),e.tickMagnitudes.length>50&&e.tickMagnitudes.shift(),e.tickMagnitudes.length<3){e.volatility=Math.max(.1,(e.volatility||.1)*.99);return}const i=e.tickMagnitudes.reduce((l,h)=>l+h,0)/e.tickMagnitudes.length,r=e.ticks.length/(1e4/1e3),n=Math.min(i/2,3),s=Math.min(r/2,2),o=n*.7+s*.3,d=.1;e.volatility=(e.volatility||0)*(1-d)+o*d,e.volatility=Math.max(.1,e.volatility)}function u(){if(!a.priceBucketSize||a.priceBucketSize<=0)return{levels:[]};const t=new Map;return(a.distributionDepthMode==="all"?e.allTicks:e.allTicks.slice(-Math.floor(e.allTicks.length*(a.distributionPercentage/100)))).forEach(i=>{const r=Math.floor(i.price*(1e4/a.priceBucketSize)),n=t.get(r)||{buy:0,sell:0,total:0};i.direction>0?n.buy++:n.sell++,n.total++,t.set(r,n)}),{levels:Array.from(t.entries()).map(([i,r])=>({price:i*(a.priceBucketSize/1e4),volume:r.total,buy:r.buy,sell:r.sell})).sort((i,r)=>i.price-r.price)}}})();
